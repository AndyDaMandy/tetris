<script>
    "use strict"
    function cell_make(i, j) {
        return {
            filled: false
        };
    }

    function grid_make(opts) {
        opts = opts || {};
        // Make grid with 20 visible rows and 20 hidden buffer rows above.
        let nrows = 20 + 20;
        let ncols = 10;
        if (opts.use_test_grid || false) {
            nrows = 6;
            ncols = 5;
        }

        const obj = {
            data: []
        };
        for (let i = 0; i < nrows; i++) {
            const row = [];
            for (let j = 0; j < ncols; j++) {
                row.push(cell_make(i, j));
            }
            obj.data.push(row);
        }

        obj.get = function (i, j) {
            console.assert(i >= 0 && i < obj.data.length);
            console.assert(j >= 0 && j < obj.data[i].length);
            return obj.data[i][j];
        }
        obj.has = function (i, j) {
            if (!(i >= 0 && i < obj.data.length)) {
                return false;
            }
            if (!(j >= 0 && j < obj.data[i].length)) {
                return false;
            }
            return true;
        }
        obj.nrows = function () {
            return obj.data.length;
        }
        obj.ncols = function () {
            return obj.data[0].length;
        }
        return obj;
    }

    function tetrimino_make(opts) {
        opts = opts || {};
        const obj = {
            i: opts.i !== undefined ? opts.i : 0,
            j: opts.j !== undefined ? opts.j : 1,
            type: opts.type || "test",
            rotation_index: opts.rotation_index || 0
        };

        const rotation_map = {
            /* Test shape is two blocks.
             * O is the origin.
             *
             *                 X
             *   OX   O   XO   O
             *        X
             */
            "test": [
                [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: 1 }],
                [{ iOffset: 0, jOffset: 0 }, { iOffset: 1, jOffset: 0 }],
                [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: -1 }],
                [{ iOffset: 0, jOffset: 0 }, { iOffset: 1, jOffset: 0 }]
            ]
        }

        // kick_map determines which offsets are tested when a rotation fails.
        // kick_map maps the current rotation_index and the desired direction to a sequence of kick values.
        // Refer: https://tetris.wiki/Super_Rotation_System
        const kick_map = {
            "test": {
                0: {
                    "left": [{ iOffset: 0, jOffset: 0 }, { iOffset: 1, jOffset: 0 }],
                    "right": [{ iOffset: 0, jOffset: 0 }, { iOffset: -1, jOffset: 0 }]
                },
                1: {
                    "left": [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: -1 }],
                    "right": [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: 1 }]
                },
                2: {
                    "left": [{ iOffset: 0, jOffset: 0 }, { iOffset: -1, jOffset: 0 }],
                    "right": [{ iOffset: 0, jOffset: 0 }, { iOffset: 1, jOffset: 0 }]
                },
                3: {
                    "left": [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: 1 }],
                    "right": [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: -1 }]
                }
            }
        };

        // get_coordinates returns the coordinates of the tetrimino that are currently filled.
        obj.get_coordinates = function () {
            if (obj.type in rotation_map) {
                const offsets = rotation_map[obj.type][obj.rotation_index];
                let coords = [];
                offsets.forEach((off) => {
                    coords.push({ i: obj.i + off.iOffset, j: obj.j + off.jOffset });
                });
                return coords;
            } else {
                console.assert("Don't know how to get_coordinates for type: %s", obj.type);
            }
        };

        obj.get_rotations = function () {
            console.assert(obj.type in rotation_map);
            return rotation_map[obj.type];
        };

        obj.get_kicks = function (dir) {
            console.assert(obj.rotation_index in kick_map[obj.type]);
            console.assert(dir in kick_map[obj.type][obj.rotation_index]);
            return kick_map[obj.type][obj.rotation_index][dir];
        };

        return obj;
    }

    function game_make(opts) {
        opts = opts || {};
        const obj = {};
        // tetrimino is the active tetrimino.
        let tetrimino = null;
        const grid = grid_make(opts.grid || {});
        let fixed_gravity = opts.fixed_gravity;
        let gravity_counter = 0;
        let lock_timer = 0;
        let locking = false;
        const kDASDelayFrames = 10;
        let das_delay_frame_countdown = 0;
        const kDASRepeatFrames = 3;
        let das_repeat_frame_countdown = 0;
        const kDASNone = 0, kDASWantRight = 1, kDASRight = 2, kDASWantLeft = 3, kDASLeft = 4;
        let das_state = kDASNone;
        let total_lines_cleared = 0;
        let cleared_300 = false;

        obj.get_level = function () {
            // Level increases every 10 lines cleared.
            return 1 + Math.floor(total_lines_cleared / 10);
        }

        obj.is_ended = function () {
            return total_lines_cleared >= 300;
        }

        obj.get_gravity = function () {
            if (fixed_gravity) {
                return fixed_gravity;
            }
            // When the level increases, so does the gravity.
            // The gravity reaches its maximum 20G at level 20.
            const level = obj.get_level();
            if (level >= 20) {
                return 20;
            }
            const g_map = {
                // Values 1-15 are copied from: https://harddrop.com/wiki/Tetris_Worlds
                1: 0.01667,
                2: 0.021017,
                3: 0.026977,
                4: 0.035256,
                5: 0.04693,
                6: 0.06361,
                7: 0.0879,
                8: 0.1236,
                9: 0.1775,
                10: 0.2598,
                11: 0.388,
                12: 0.59,
                13: 0.92,
                14: 1.46,
                15: 2.36,
                // Values 15-18 are computed from (0.8-((Level-1)*0.007))(Level-1)
                16: 3.9090991031125726,
                17: 6.613536242572853,
                18: 11.437940870718618,
                // Value 19 is a fixed "20" since result of formula is greater than 20.
                19: 20
            }
            console.assert(level in g_map);
            return g_map[level];
        };

        // is_colliding_below returns true if tetrimino has a filled cell or floor below.
        function is_colliding_below() {
            console.assert(tetrimino);

            const t = tetrimino;
            const coords = t.get_coordinates();
            for (let i = 0; i < coords.length; i++) {
                const pair = coords[i];
                if (pair.i + 1 == grid.nrows()) {
                    return true;
                }
                if (grid.has(pair.i + 1, pair.j)) {
                    const cell = grid.get(pair.i + 1, pair.j);
                    if (cell.filled) {
                        return true;
                    }
                }
            }
            return false;
        }

        // try_rotate tries to rotate in direction `dir`.
        // All kicks are tried in sequence. If all kicks fail, rotation does not occur.
        function try_rotate(dir) {
            console.assert(tetrimino);
            const t = tetrimino;
            console.assert(dir == "left" || dir == "right", "expected 'left' or 'right', got %s", dir);
            const rotations = t.get_rotations();
            let target_index = dir == "right" ? t.rotation_index + 1 : t.rotation_index - 1;
            if (target_index < 0) {
                target_index = rotations.length - 1;
            } else if (target_index > rotations.length - 1) {
                target_index = 0;
            }

            // can_rotate checks if applying `kick` results in a successful rotation.
            function can_rotate(kick) {
                const rotation = rotations[target_index];
                let all_empty = true;
                for (let i = 0; i < rotation.length; i++) {
                    const pair = {
                        i: t.i + kick.iOffset + rotation[i].iOffset,
                        j: t.j + kick.jOffset + rotation[i].jOffset,
                    };
                    if (!grid.has(pair.i, pair.j)) {
                        all_empty = false;
                        break;
                    }
                    if (grid.get(pair.i, pair.j).filled) {
                        all_empty = false;
                        break;
                    }
                }
                return all_empty;
            }

            // Try to apply each kick in sequence until rotation succeeds.
            let kick_to_apply = null;
            const kicks = t.get_kicks(dir);
            for (let i = 0; i < kicks.length; i++) {
                const kick = kicks[i];
                if (can_rotate(kick)) {
                    kick_to_apply = kick;
                    break;
                }
            }

            if (kick_to_apply === null) {
                return;
            }

            // Apply kick to position.
            t.i += kick_to_apply.iOffset;
            t.j += kick_to_apply.jOffset;
            // Apply rotation.
            t.rotation_index = target_index;
        }

        // try_move tries to move tetrimino in direction `dir`.
        function try_move(dir) {
            console.assert(tetrimino);
            const t = tetrimino;

            let jOffset;
            if (dir == "left") {
                jOffset = -1;
            }
            else if (dir == "right") {
                jOffset = +1;
            }
            else {
                throw "Do not know how to move in direction '" + dir + "'";
            }

            const coords = t.get_coordinates();
            for (let i = 0; i < coords.length; i++) {
                const pair = coords[i];
                if (!grid.has(pair.i, pair.j + jOffset)) {
                    return;
                }
                const cell = grid.get(pair.i, pair.j + jOffset);
                if (cell.filled) {
                    return;
                }
            }
            // All destination cells are clear. Apply move.
            t.j += jOffset;
        }


        let events = {};

        function clear_events() {
            events = {
                rotate_left: false,
                rotate_right: false,
                move_left: false,
                move_right: false,
                hard_drop: false,
                soft_drop: false
            }
        }

        clear_events();

        obj.add_tetrimino = function (t) {
            console.assert(tetrimino == null);
            tetrimino = t;
        };

        obj.rotate_left = function () {
            events.rotate_left = true;
        };

        obj.rotate_right = function () {
            events.rotate_right = true;
        };

        obj.move_left = function () {
            events.move_left = true;
        };

        obj.move_right = function () {
            events.move_right = true;
        };

        obj.hard_drop = function () {
            events.hard_drop = true;
        }

        obj.soft_drop = function () {
            events.soft_drop = true;
        }

        obj.tick_frame = function () {
            let t = tetrimino;
            let in_soft_drop = false;

            // Handle events.
            if (events.rotate_left) {
                if (t) {
                    try_rotate("left");
                }
            }
            if (events.rotate_right) {
                if (t) {
                    try_rotate("right");
                }
            }
            if (events.move_left) {
                if (t) {
                    // Handle Delayed Auto Shift (DAS)
                    switch (das_state) {
                        case kDASRight:
                        case kDASWantRight:
                        case kDASNone:
                            // User was moving right or not moving. Make immediate move and start DAS sequence.
                            try_move("left");
                            das_state = kDASWantLeft;
                            das_delay_frame_countdown = kDASDelayFrames;
                            break;
                        case kDASWantLeft:
                            das_delay_frame_countdown--;
                            if (das_delay_frame_countdown <= 0) {
                                // Delay has completed. Begin repeating.
                                try_move("left");
                                das_state = kDASLeft;
                                das_repeat_frame_countdown = kDASRepeatFrames;
                            }
                            break;
                        case kDASLeft:
                            das_repeat_frame_countdown--;
                            if (das_repeat_frame_countdown <= 0) {
                                try_move("left");
                                das_repeat_frame_countdown = kDASRepeatFrames;
                            }
                            break;
                    }
                }
            }
            if (events.move_right) {
                if (t) {
                    // Handle Delayed Auto Shift (DAS)
                    switch (das_state) {
                        case kDASLeft:
                        case kDASWantLeft:
                        case kDASNone:
                            // User was moving left or not moving. Make immediate move and start DAS sequence.
                            try_move("right");
                            das_state = kDASWantRight;
                            das_delay_frame_countdown = kDASDelayFrames;
                            break;
                        case kDASWantRight:
                            das_delay_frame_countdown--;
                            if (das_delay_frame_countdown <= 0) {
                                // Delay has completed. Begin repeating.
                                try_move("right");
                                das_state = kDASRight;
                                das_repeat_frame_countdown = kDASRepeatFrames;
                            }
                            break;
                        case kDASRight:
                            das_repeat_frame_countdown--;
                            if (das_repeat_frame_countdown <= 0) {
                                try_move("right");
                                das_repeat_frame_countdown = kDASRepeatFrames;
                            }
                            break;
                    }
                }
            }

            if (!events.move_left && !events.move_right) {
                das_state = kDASNone;
            }

            if (events.hard_drop) {
                if (t) {
                    while (!is_colliding_below()) {
                        t.i++;
                    }
                    locking = true;
                    lock_timer = 1; // Lock this frame.
                }
            }
            if (events.soft_drop) {
                in_soft_drop = true;
            }
            clear_events();

            // Apply gravity.
            // Tetriminos move at a rate of `gravity` cells per frame.
            if (t) {
                let gravity = obj.get_gravity();
                // From https://tetris.wiki/Drop
                // "Soft dropping a tetromino generally makes it falls at around 20 to 60 blocks per second, as fast as or faster than DAS"
                // tetris.com appears to use the same speed as DAS. Default DAS is 50ms.
                // 50ms is .3 frames.
                if (in_soft_drop && gravity < .3) {
                    gravity_counter += .3;
                } else {
                    gravity_counter += gravity;
                }

                while (gravity_counter >= 1) {
                    if (!is_colliding_below()) {
                        t.i++;
                    }
                    gravity_counter -= 1;
                    if (gravity_counter < 0) {
                        gravity_counter = 0;
                    }
                }
            }

            // Start lock timer.
            // If Tetrimino is colliding with block below, start the lock timer.
            if (is_colliding_below()) {
                if (!locking) {
                    locking = true;
                    lock_timer = 30 + 1; // Add 1 so locking state is 30 frames.
                }
            } else {
                // TODO: if tetrimino was locking, and is rotated out, is locking expected to reset?
                // Assume "no". Rationale: this permits pieces to be rotated indefinitely.
            }

            // Apply lock.
            let fill_occurred = false;
            if (locking) {
                lock_timer--;
                if (lock_timer == 0) {
                    // Fill cells with tetrimino.
                    const coords = t.get_coordinates();
                    for (let i = 0; i < coords.length; i++) {
                        const pair = coords[i];
                        const cell = grid.get(pair.i, pair.j);
                        cell.filled = true;
                    }
                    // Reset tetrimino.
                    tetrimino = null;
                    fill_occurred = true;
                }
            }

            // Check for line clears.
            if (fill_occurred) {
                let lines_cleared = 0;
                for (let i = 0; i < grid.nrows(); i++) {
                    let can_be_cleared = true;
                    for (let j = 0; j < grid.ncols(); j++) {
                        if (!grid.get(i, j).filled) {
                            can_be_cleared = false;
                            break;
                        }
                    }
                    if (can_be_cleared) {
                        // Clear, and shift cell fills down.
                        for (let ip = i; ip >= 0; ip--) {
                            for (let jp = 0; jp < grid.ncols(); jp++) {
                                const to = grid.get(ip, jp);
                                if (ip == 0) {
                                    to.filed = false;
                                } else {
                                    const from = grid.get(ip - 1, jp);
                                    to.filled = from.filled;
                                }
                            }
                        }
                        lines_cleared++;
                    }
                }

                if (lines_cleared > 0) {
                    total_lines_cleared += lines_cleared;
                }
            }
        };

        // render_text renders the tetris game in text.
        // Used for testing.
        // F == Fill
        // # == Tetrimino
        // . == Empty
        obj.render_text = function () {
            const text_grid = [];
            for (let i = 0; i < grid.nrows(); i++) {
                const row = [];
                for (let j = 0; j < grid.ncols(); j++) {
                    const cell = grid.get(i, j);
                    if (cell.filled) {
                        row.push("F");
                    } else {
                        row.push(".");
                    }
                }
                text_grid.push(row);
            }
            let t = tetrimino;
            if (t) {
                if (t.type == "test") {
                    const coords = t.get_coordinates();
                    coords.forEach((pair) => {
                        if (pair.i >= 0 && pair.i < text_grid.length && pair.j >= 0 && pair.j < text_grid[pair.i].length) {
                            text_grid[pair.i][pair.j] = "#";
                        }
                    });
                } else {
                    throw "Do not know how to apply tetrimino of type: " + t.type
                }
            }
            // Render to string.
            let ret = "";
            for (let i = 0; i < grid.nrows(); i++) {
                if (i > 0) ret += "\n";
                ret += text_grid[i].join("");
            }
            return ret;
        };
        obj.get_grid = function () {
            // TODO: can I return a read-only view of an object?
            return grid;
        }
        return obj;
    }

    // Tests ... begin
    function assert_rendered(game, expected) {
        const got = game.render_text();
        expected = expected.join("\n");
        console.assert(got == expected, "expected grid:\n%s\ngot grid:\n%s\n", expected, got);
    }
    function test_add_tetrimino() {
        const game = game_make({ grid: { use_test_grid: true } });
        game.add_tetrimino(tetrimino_make());
        assert_rendered(game,
            [
                ".##..",
                ".....",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
    }
    function test_gravity() {
        const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: .5 });
        game.add_tetrimino(tetrimino_make());
        assert_rendered(game,
            [
                ".##..",
                ".....",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
        game.tick_frame();
        assert_rendered(game,
            [
                ".##..",
                ".....",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
        game.tick_frame();
        assert_rendered(game,
            [
                ".....",
                ".##..",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
        // Test gravity > 1
        {
            const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: 2 });
            game.add_tetrimino(tetrimino_make());
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
    }
    function test_lock() {
        const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: 1 });
        game.add_tetrimino(tetrimino_make({ i: 4 }));
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".##..",
                "....."
            ]);
        game.tick_frame();
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".....",
                ".##.."
            ]);
        // Tick 29 frames.
        for (let i = 0; i < 29; i++) game.tick_frame();
        // Expect still not locked.
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".....",
                ".##.."
            ]);
        // Wait another frame.
        game.tick_frame();
        // Expect locked.
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".....",
                ".FF.."
            ]);

        // Test lock with high fixed_gravity.
        {
            const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: 4 });
            game.add_tetrimino(tetrimino_make({ i: 4 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##..",
                    "....."
                ]);
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##.."
                ]);
            // Tick 29 frames.
            for (let i = 0; i < 29; i++) game.tick_frame();
            // Expect still not locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##.."
                ]);
            // Wait another frame.
            game.tick_frame();
            // Expect locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".FF.."
                ]);
        }
    }

    function test_rotate() {
        // Test basic rotate.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            game.add_tetrimino(tetrimino_make({ i: 1 }));
            assert_rendered(game,
                [
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.rotate_right();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".#...",
                    ".#...",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
        // Test wall kick.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            game.add_tetrimino(tetrimino_make({ i: 0, j: 0, rotation_index: 1 }));
            assert_rendered(game,
                [
                    "#....",
                    "#....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.rotate_right();
            game.tick_frame();
            assert_rendered(game,
                [
                    "##...",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
        // Test floor kick.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            game.add_tetrimino(tetrimino_make({ i: 5, j: 1, rotation_index: 0 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##.."
                ]);
            game.rotate_right();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".#...",
                    ".#..."
                ]);
        }
        // Test failed rotation.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            grid.get(4, 1).filled = true;
            grid.get(5, 1).filled = true;
            game.add_tetrimino(tetrimino_make({ i: 4, j: 0, rotation_index: 1 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "#F...",
                    "#F..."
                ]);
            game.rotate_left();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "#F...",
                    "#F..."
                ]);
        }
    }

    function test_line_clear() {
        function fill_region(grid, start, end) {
            console.assert(start.i <= end.i);
            console.assert(start.j <= end.j);
            for (let i = start.i; i <= end.i; i++) {
                for (let j = start.j; j <= end.j; j++) {
                    grid.get(i, j).filled = true;
                }
            }
        }
        // Test single line clear.
        {
            const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: 1 });
            const grid = game.get_grid();
            fill_region(grid, { i: 5, j: 0 }, { i: 5, j: 3 });
            game.add_tetrimino(tetrimino_make({ i: 3, j: 4, rotation_index: 1 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    "....#",
                    "....#",
                    "FFFF."
                ]);
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....#",
                    "FFFF#"
                ]);
            // Tick 30 frames to lock.
            for (let i = 0; i < 30; i++) {
                game.tick_frame();
            }
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....F"
                ]);

        }
        // Test split clear (TODO: need more pieces).
        {

        }
    }

    function test_move() {
        // Test move left / right.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            game.add_tetrimino(tetrimino_make({ i: 0, j: 1, rotation_index: 0 }));
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.move_left();
            game.tick_frame();
            assert_rendered(game,
                [
                    "##...",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            // Test that cannot move beyond wall.
            game.move_left();
            game.tick_frame();
            assert_rendered(game,
                [
                    "##...",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            // Test that cannot move beyond wall.
            game.move_right();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
        // Test delayed auto shift.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            game.add_tetrimino(tetrimino_make({ i: 0, j: 3, rotation_index: 0 }));
            assert_rendered(game,
                [
                    "...##",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.move_left();
            game.tick_frame();
            assert_rendered(game,
                [
                    "..##.",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            // After 9 frames, no move has occurred yet.
            for (let i = 0; i < 9; i++) {
                game.move_left();
                game.tick_frame();
            }
            assert_rendered(game,
                [
                    "..##.",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            // After 10th frame, enter Delayed Auto Shift.
            game.move_left();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            // In Delayed Auto Shift, move every 3 frames.
            for (let i = 0; i < 2; i++) {
                game.move_left();
                game.tick_frame();
            }
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.move_left();
            game.tick_frame();
            assert_rendered(game,
                [
                    "##...",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
    }

    function test_hard_drop() {
        // Test move left / right.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            game.add_tetrimino(tetrimino_make({ i: 0, j: 1, rotation_index: 0 }));
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.hard_drop();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".FF.."
                ]);
        }
    }

    function test_soft_drop() {
        // Test basic soft drop.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            game.add_tetrimino(tetrimino_make({ i: 0, j: 1, rotation_index: 0 }));
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            for (let i = 0; i < 3; i++) {
                game.soft_drop();
                game.tick_frame();
                assert_rendered(game,
                    [
                        ".##..",
                        ".....",
                        ".....",
                        ".....",
                        ".....",
                        "....."
                    ]);
            }
            game.soft_drop();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
        // Test soft drop does not slow down high gravity.
        {
            const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: 1 });
            const grid = game.get_grid();
            game.add_tetrimino(tetrimino_make({ i: 0, j: 1, rotation_index: 0 }));
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);

            game.soft_drop();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);

        }
    }
    function test_levels() {
        // fill_bottom_row unfills all cells and fills all in bottom row except left-most.
        function fill_bottom_row(grid) {
            // Clear.
            for (let i = 0; i < grid.nrows(); i++) {
                for (let j = 0; j < grid.ncols(); j++) {
                    const cell = grid.get(i, j);
                    cell.filled = false;
                }
            }

            // Fill all in bottom row but bottom left.
            for (let j = 1; j < grid.ncols(); j++) {
                const cell = grid.get(grid.nrows() - 1, j);
                cell.filled = true;
            }
        }

        function clear_one_line(game) {
            // Assume no tetrimino is added.
            game.add_tetrimino(tetrimino_make({ i: 0, j: 0, rotation_index: 1 }));
            fill_bottom_row(game.get_grid());
            assert_rendered(game,
                [
                    "#....",
                    "#....",
                    ".....",
                    ".....",
                    ".....",
                    ".FFFF"
                ]);
            game.hard_drop();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "F...."
                ]);
        }

        // Test level increases every 10 lines cleared.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            for (let i = 0; i < 9; i++) {
                clear_one_line(game);
            }
            console.assert(game.get_level() == 1, "expected level 1, got %d", game.get_level());
            clear_one_line(game);
            console.assert(game.get_level() == 2, "expected level 2, got %d", game.get_level());
            for (let i = 0; i < 10; i++) {
                clear_one_line(game);
            }
            console.assert(game.get_level() == 3, "expected level 3, got %d", game.get_level());
        }
        // Test game ends at 300 lines cleared.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            for (let i = 0; i < 299; i++) {
                clear_one_line(game);
            }
            console.assert(!game.is_ended());
            clear_one_line(game);
            console.assert(game.is_ended());
        }
        // Test gravity caps at 20G.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            for (let i = 0; i < 19 * 10 - 1; i++) {
                clear_one_line(game);
            }
            console.assert(game.get_level() == 19, "expected level 19, got %d", game.get_level());
            console.assert(game.get_gravity() == 20, `expected gravity 20, got ${game.get_gravity()}`);
            clear_one_line(game);
            console.assert(game.get_level() == 20, "expected level 20, got %d", game.get_level());
            console.assert(game.get_gravity() == 20, `expected gravity 20, got ${game.get_gravity()}`);
            for (let i = 0; i < 10; i++) {
                clear_one_line(game);
            }
            console.assert(game.get_level() == 21, "expected level 21, got %d", game.get_level());
            console.assert(game.get_gravity() == 20, `expected gravity 20, got ${game.get_gravity()}`);
        }
    }
    test_add_tetrimino();
    test_gravity();
    test_lock();
    test_rotate();
    test_line_clear();
    test_move();
    test_hard_drop();
    test_soft_drop();
    test_levels();
    // Tests ... end
</script>