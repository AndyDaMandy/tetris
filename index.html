<html>

<head>
    <title>Tetris</title>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-HDRY5R79EL"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-HDRY5R79EL');
    </script>
    <style type="text/css">
        canvas {
            border: 1px black solid;
        }
    </style>
</head>

<body>
    <canvas id="render_canvas" width="304" height="408"></canvas>
    <div style="font-family: 'Courier New'" id="render_text"></div>
    <p style="font-family: 'Courier New'"><a href="https://github.com/kevinAlbs/tetris">See Source</a></p>
    <script src="game.js"></script>
    <script src="tests.js"></script>
    <script>
        window.onload = main;

        const cnv = document.querySelector("#render_canvas")
        const ctx = cnv.getContext("2d");
        const kCanvasWidth = cnv.width;
        const kCanvasHeight = cnv.height;
        const kCellWidth = 20;
        const kGridWidth = kCellWidth * 10;
        const kGridHeight = kCellWidth * 20;
        const typeToFillStyle = {
            "test": "#FFF",
            "Z": "#ff0400",
            "L": "#ff6a00",
            "O": "#ffd800",
            "S": "#03ff22",
            "I": "#04cbff",
            "J": "#0026ff",
            "T": "#b200ff"
        };

        const typeToStrokeStyle = {
            "test": "#333",
            "Z": "#333",
            "L": "#333",
            "O": "#333",
            "S": "#333",
            "I": "#333",
            "J": "#333",
            "T": "#333"
        };

        let flash_score_message_counter_ms = 0;
        let flash_score_message = "";
        let flash_score_value = 0;
        function do_render(game, delta_ms) {
            const grid = game.get_grid();
            ctx.clearRect(0, 0, kCanvasWidth, kCanvasHeight);
            ctx.fillStyle = "#222"
            ctx.fillRect(0, 0, kCanvasWidth, kCanvasHeight);
            const gridOffset = {
                x: 100,
                y: 4
            }

            // Render border around grid.
            {
                ctx.strokeStyle = "#EEE"
                ctx.lineWidth = 4;
                ctx.strokeRect(gridOffset.x - 2, gridOffset.y - 2, kGridWidth + 4, kGridHeight + 4);
            }

            // Render grid lines.
            for (let j = 0; j <= grid.ncols(); j++) {
                let startX = gridOffset.x + j * kCellWidth - 1;
                ctx.fillStyle = "#333"
                ctx.fillRect(startX, gridOffset.y, 2, kGridHeight);
            }

            for (let i = 0; i <= grid.nrows(); i++) {
                let startY = gridOffset.y + i * kCellWidth - 1;
                ctx.fillStyle = "#333"
                ctx.fillRect(gridOffset.x, startY, kGridWidth, 2);
            }

            for (let i = 0; i < grid.nrows(); i++) {
                for (let j = 0; j < grid.ncols(); j++) {
                    const cell = grid.get(i, j);
                    if (cell.filled) {
                        ctx.fillStyle = typeToFillStyle[cell.fillType];
                        ctx.fillRect(gridOffset.x + j * kCellWidth, gridOffset.y + i * kCellWidth, kCellWidth, kCellWidth);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = typeToStrokeStyle[cell.fillType];
                        ctx.strokeRect(1 + gridOffset.x + j * kCellWidth, 1 + gridOffset.y + i * kCellWidth, -1 + kCellWidth, -1 + kCellWidth);
                    }
                }
            }

            const ghost_piece = game.get_ghost_piece();
            if (ghost_piece) {
                const coords = ghost_piece.get_coordinates();
                for (let idx = 0; idx < coords.length; idx++) {
                    const pair = coords[idx];
                    ctx.fillStyle = "#555";
                    ctx.fillRect(gridOffset.x + pair.j * kCellWidth, gridOffset.y + pair.i * kCellWidth, kCellWidth, kCellWidth);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = "#333";
                    ctx.strokeRect(1 + gridOffset.x + pair.j * kCellWidth, 1 + gridOffset.y + pair.i * kCellWidth, -1 + kCellWidth, -1 + kCellWidth);
                }
            }

            const tetrimino = game.get_tetrimino();
            if (tetrimino) {
                const coords = tetrimino.get_coordinates();
                for (let idx = 0; idx < coords.length; idx++) {
                    const pair = coords[idx];
                    ctx.fillStyle = typeToFillStyle[tetrimino.type];
                    ctx.fillRect(gridOffset.x + pair.j * kCellWidth, gridOffset.y + pair.i * kCellWidth, kCellWidth, kCellWidth);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = typeToStrokeStyle[tetrimino.type];
                    ctx.strokeRect(1 + gridOffset.x + pair.j * kCellWidth, 1 + gridOffset.y + pair.i * kCellWidth, -1 + kCellWidth, -1 + kCellWidth);
                }
            }

            // Render hold piece.
            const holdOffset = {
                x: 10,
                y: 10
            };
            if (game.get_hold_tetrimino_type() !== null) {
                const hold_tetrimino = tetrimino_make({ type: game.get_hold_tetrimino_type() });
                const coords = hold_tetrimino.get_coordinates();
                for (let idx = 0; idx < coords.length; idx++) {
                    const pair = coords[idx];
                    ctx.fillStyle = typeToFillStyle[hold_tetrimino.type];
                    ctx.fillRect(holdOffset.x + pair.j * kCellWidth, holdOffset.y + pair.i * kCellWidth, kCellWidth, kCellWidth);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = typeToStrokeStyle[hold_tetrimino.type];
                    ctx.strokeRect(1 + holdOffset.x + pair.j * kCellWidth, 1 + holdOffset.y + pair.i * kCellWidth, -1 + kCellWidth, -1 + kCellWidth);
                }
            }

            if (game.get_has_lost()) {
                ctx.fillStyle = "#FFF";
                ctx.font = "20px 'Courier New'";
                ctx.textAlign = "center";
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 3;
                ctx.strokeText("Game Over", gridOffset.x + kGridWidth / 2, gridOffset.y + 100, kGridWidth);
                ctx.fillText("Game Over", gridOffset.x + kGridWidth / 2, gridOffset.y + 100, kGridWidth);
                ctx.font = "14px 'Courier New'";
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 3;
                ctx.strokeText("Press R to restart", gridOffset.x + kGridWidth / 2, gridOffset.y + 120, kGridWidth);
                ctx.fillText("Press R to restart", gridOffset.x + kGridWidth / 2, gridOffset.y + 120, kGridWidth);
                return;
            }

            if (game.get_paused()) {
                ctx.fillStyle = "#FFF";
                ctx.font = "20px 'Courier New'";
                ctx.textAlign = "center";
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 3;
                ctx.strokeText("Paused", gridOffset.x + kGridWidth / 2, gridOffset.y + 100, kGridWidth);
                ctx.fillText("Paused", gridOffset.x + kGridWidth / 2, gridOffset.y + 100, kGridWidth);
                ctx.font = "14px 'Courier New'";
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 3;
                ctx.strokeText("Press P to unpause", gridOffset.x + kGridWidth / 2, gridOffset.y + 120, kGridWidth);
                ctx.fillText("Press P to unpause", gridOffset.x + kGridWidth / 2, gridOffset.y + 120, kGridWidth);
                return;
            }

            if (game.get_score_occurred()) {
                flash_score_message_counter_ms = 1000;
            }
            if (flash_score_message_counter_ms > 0) {
                if (game.get_score_value() > 0) {
                    flash_score_message = game.get_score_message();
                    flash_score_value = "+" + game.get_score_value();
                }
                flash_score_message_counter_ms -= delta_ms;
            } else {
                flash_score_message = "";
            }

            if (flash_score_message != "") {
                ctx.fillStyle = "#FFF";
                ctx.font = "20px 'Courier New'";
                ctx.textAlign = "center";
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 3;
                ctx.strokeText(flash_score_message, gridOffset.x + kGridWidth / 2, gridOffset.y + 100, kGridWidth);
                ctx.fillText(flash_score_message, gridOffset.x + kGridWidth / 2, gridOffset.y + 100, kGridWidth);
                ctx.font = "14px 'Courier New'";
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 3;
                ctx.strokeText(flash_score_value, gridOffset.x + kGridWidth / 2, gridOffset.y + 120, kGridWidth);
                ctx.fillText(flash_score_value, gridOffset.x + kGridWidth / 2, gridOffset.y + 120, kGridWidth);
                return;
            }
        }

        let copy_debug_info = null;
        function main() {
            const game = game_make({ grid: { use_test_grid: false }, enable_spawn: true, show_ghost_piece: true });
            game.register_event_listeners();
            game.loop({
                render_callback: function (delta_ms) { do_render(game, delta_ms); },
            });
            copy_debug_info = function () {
                console.log();
                const debug_info = game.get_debug_info();
                for (let i = 0; i < debug_info.last_n_renders.length; i++) {
                    debug_info.last_n_renders[i] = debug_info.last_n_renders[i].split("\n");
                }
                copy(JSON.stringify(debug_info, null, "    "));
                console.log("Debug info is copied. Paste into a file. Upload the file to a GitHub issue to report a bug: https://github.com/kevinAlbs/tetris/issues");
            }
        }
        console.log("To report a bug, copy debug info with: `copy_debug_info()`");
    </script>
</body>

</html>