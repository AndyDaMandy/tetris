<script>
    "use strict"
    function cell_make(i, j) {
        return {
            filled: false
        };
    }

    function grid_make(opts) {
        opts = opts || {};
        // Make grid with 20 visible rows and 20 hidden buffer rows above.
        let nrows = 20 + 20;
        let ncols = 10;
        if (opts.use_test_grid || false) {
            nrows = 6;
            ncols = 5;
        }

        const obj = {
            data: []
        };
        for (let i = 0; i < nrows; i++) {
            const row = [];
            for (let j = 0; j < ncols; j++) {
                row.push(cell_make(i, j));
            }
            obj.data.push(row);
        }

        obj.get = function (i, j) {
            console.assert(i >= 0 && i < obj.data.length);
            console.assert(j >= 0 && j < obj.data[i].length);
            return obj.data[i][j];
        }
        obj.has = function (i, j) {
            if (!(i >= 0 && i < obj.data.length)) {
                return false;
            }
            if (!(j >= 0 && j < obj.data[i].length)) {
                return false;
            }
            return true;
        }
        obj.nrows = function () {
            return obj.data.length;
        }
        obj.ncols = function () {
            return obj.data[0].length;
        }
        return obj;
    }

    function tetrimino_make(opts) {
        opts = opts || {};
        const obj = {
            i: opts.i || 0,
            j: opts.j || 1,
            type: opts.type || "test",
            gravity_counter: 0,
            lock_timer: 0,
            locking: false
        };

        // get_coordinates returns the coordinates of the tetrimino that are currently filled.
        obj.get_coordinates = function () {
            if (obj.type == "test") {
                return [{ i: obj.i, j: obj.j }];
            } else {
                console.assert("Don't know how to get_coordinates for type: %s", obj.type);
            }
        };
        return obj;
    }

    function game_make(opts) {
        opts = opts || {};
        const obj = {};
        // tetrimino is the active tetrimino.
        let tetrimino = null;
        const grid = grid_make(opts.grid || {});
        let gravity = opts.gravity || .1;

        // is_colliding_below returns true if tetrimino has a filled cell or floor below.
        function is_colliding_below() {
            console.assert(tetrimino);

            const t = tetrimino;
            const coords = t.get_coordinates();
            for (let i = 0; i < coords.length; i++) {
                const pair = coords[i];
                if (pair.i + 1 == grid.nrows()) {
                    return true;
                }
                if (grid.has(pair.i + 1, pair.j)) {
                    const cell = grid.get(pair.i + 1, pair.j);
                    if (cell.filled) {
                        return true;
                    }
                }
            }
            return false;
        }

        obj.add_tetrimino = function (t) {
            console.assert(tetrimino == null);
            tetrimino = t;
        };
        obj.tick_frame = function () {
            // Tetriminos move at a rate of `gravity` cells per frame.
            let t = tetrimino;
            if (t) {
                t.gravity_counter += opts.gravity;
                while (t.gravity_counter >= 1) {
                    if (!is_colliding_below()) {
                        t.i++;
                    }
                    t.gravity_counter -= 1;
                    if (t.gravity_counter < 0) {
                        t.gravity_counter = 0;
                    }
                }
            }

            // If Tetrimino is colliding with block below, start the lock timer.
            if (is_colliding_below()) {
                if (!t.locking) {
                    t.locking = true;
                    t.lock_timer = 30 + 1; // Add 1 so locking state is 30 frames.
                }
            } else {
                // TODO: if tetrimino was locking, and is rotated out, is locking expected to reset?
                // Assume "no". Rationale: this permits pieces to be rotated indefinitely.
            }

            if (t.locking) {
                t.lock_timer--;
                if (t.lock_timer == 0) {
                    // Fill cells with tetrimino.
                    const coords = t.get_coordinates();
                    for (let i = 0; i < coords.length; i++) {
                        const pair = coords[i];
                        console.log(pair);
                        const cell = grid.get(pair.i, pair.j);
                        cell.filled = true;
                    }
                    // Reset tetrimino.
                    tetrimino = null;
                }
            }
        };

        // render_text renders the tetris game in text.
        // Used for testing.
        // F == Fill
        // # == Tetrimino
        // . == Empty
        obj.render_text = function () {
            const text_grid = [];
            for (let i = 0; i < grid.nrows(); i++) {
                const row = [];
                for (let j = 0; j < grid.ncols(); j++) {
                    const cell = grid.get(i, j);
                    if (cell.filled) {
                        row.push("F");
                    } else {
                        row.push(".");
                    }
                }
                text_grid.push(row);
            }
            let t = tetrimino;
            if (t) {
                if (t.type == "test") {
                    if (t.i >= 0 && t.i < text_grid.length && t.j >= 0 && t.j < text_grid[t.i].length) {
                        text_grid[t.i][t.j] = "#";
                    }
                } else {
                    throw "Do not know how to apply tetrimino of type: " + t.type
                }
            }
            // Render to string.
            let ret = "";
            for (let i = 0; i < grid.nrows(); i++) {
                if (i > 0) ret += "\n";
                ret += text_grid[i].join("");
            }
            return ret;
        };
        obj.get_grid = function () {
            // TODO: can I return a read-only view of an object?
            return grid;
        }
        return obj;
    }

    // Tests ... begin
    function assert_rendered(game, expected) {
        const got = game.render_text();
        expected = expected.join("\n");
        console.assert(got == expected, "expected grid:\n%s\ngot grid:\n%s\n", expected, got);
    }
    function test_add_tetrimino() {
        const game = game_make({ grid: { use_test_grid: true } });
        game.add_tetrimino(tetrimino_make());
        assert_rendered(game,
            [
                ".#...",
                ".....",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
    }
    function test_gravity() {
        const game = game_make({ grid: { use_test_grid: true }, gravity: .5 });
        game.add_tetrimino(tetrimino_make());
        assert_rendered(game,
            [
                ".#...",
                ".....",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
        game.tick_frame();
        assert_rendered(game,
            [
                ".#...",
                ".....",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
        game.tick_frame();
        assert_rendered(game,
            [
                ".....",
                ".#...",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
        // Test gravity > 1
        {
            const game = game_make({ grid: { use_test_grid: true }, gravity: 2 });
            game.add_tetrimino(tetrimino_make());
            assert_rendered(game,
                [
                    ".#...",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".#...",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
    }
    function test_lock() {
        const game = game_make({ grid: { use_test_grid: true }, gravity: 1 });
        game.add_tetrimino(tetrimino_make({ i: 4 }));
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".#...",
                "....."
            ]);
        game.tick_frame();
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".....",
                ".#..."
            ]);
        // Tick 29 frames.
        for (let i = 0; i < 29; i++) game.tick_frame();
        // Expect still not locked.
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".....",
                ".#..."
            ]);
        // Wait another frame.
        game.tick_frame();
        // Expect locked.
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".....",
                ".F..."
            ]);

        // Test lock with high gravity.
        {
            const game = game_make({ grid: { use_test_grid: true }, gravity: 4 });
            game.add_tetrimino(tetrimino_make({ i: 4 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".#...",
                    "....."
                ]);
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".#..."
                ]);
            // Tick 29 frames.
            for (let i = 0; i < 29; i++) game.tick_frame();
            // Expect still not locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".#..."
                ]);
            // Wait another frame.
            game.tick_frame();
            // Expect locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".F..."
                ]);
        }
    }
    // test_add_tetrimino();
    // test_gravity();
    test_lock();
    // Tests ... end
</script>