<div style="font-family: 'Courier New'" id="display_text"></div>
<script>
    "use strict"
    function cell_make(i, j) {
        return {
            filled: false
        };
    }

    function grid_make(opts) {
        opts = opts || {};
        // Make grid with 20 visible rows and 20 hidden buffer rows above.
        let nrows = 20;
        let ncols = 10;
        if (opts.use_test_grid || false) {
            nrows = 6;
            ncols = 5;
        }

        const obj = {
            data: [],
            buffer: []
        };

        for (let i = 0; i < nrows; i++) {
            const row = [];
            for (let j = 0; j < ncols; j++) {
                row.push(cell_make(i, j));
            }
            obj.data.push(row);
        }

        // Add hidden buffer rows.
        // Hidden buffer rows are accessed by calling `get` with a negative row.
        for (let i = 0; i < nrows; i++) {
            const row = [];
            for (let j = 0; j < ncols; j++) {
                row.push(cell_make(i, j));
            }
            obj.buffer.push(row);
        }

        obj.get = function (i, j) {
            console.assert(i >= -nrows && i < nrows);
            console.assert(j >= 0 && j < ncols);
            if (i < 0) {
                return obj.buffer[-(i + 1)][j];
            }
            return obj.data[i][j];
        }
        obj.has = function (i, j) {
            if (!(i >= -nrows && i < nrows)) {
                return false;
            }
            if (!(j >= 0 && j < ncols)) {
                return false;
            }
            return true;
        }
        obj.has_visible = function (i, j) {
            if (!(i >= 0 && i < nrows)) {
                return false;
            }
            if (!(j >= 0 && j < ncols)) {
                return false;
            }
            return true;
        }
        obj.nrows = function () {
            return obj.data.length;
        }
        obj.ncols = function () {
            return obj.data[0].length;
        }
        return obj;
    }

    function tetrimino_make(opts) {
        opts = opts || {};
        const obj = {
            i: opts.i !== undefined ? opts.i : 0,
            j: opts.j !== undefined ? opts.j : 1,
            type: opts.type || "test",
            rotation_index: opts.rotation_index || 0
        };

        const rotation_map = {
            /* Test shape is two blocks.
             * O is the origin.
             *
             *                 X
             *   OX   O   XO   O
             *        X
             */
            "test": [
                [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: 1 }],
                [{ iOffset: 0, jOffset: 0 }, { iOffset: 1, jOffset: 0 }],
                [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: -1 }],
                [{ iOffset: 0, jOffset: 0 }, { iOffset: 1, jOffset: 0 }]
            ],

            /* I
             * 
             */
            "I": [

            ]
        }

        // kick_map determines which offsets are tested when a rotation fails.
        // kick_map maps the current rotation_index and the desired direction to a sequence of kick values.
        // Refer: https://tetris.wiki/Super_Rotation_System
        const kick_map = {
            "test": {
                0: {
                    "left": [{ iOffset: 0, jOffset: 0 }, { iOffset: 1, jOffset: 0 }],
                    "right": [{ iOffset: 0, jOffset: 0 }, { iOffset: -1, jOffset: 0 }]
                },
                1: {
                    "left": [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: -1 }],
                    "right": [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: 1 }]
                },
                2: {
                    "left": [{ iOffset: 0, jOffset: 0 }, { iOffset: -1, jOffset: 0 }],
                    "right": [{ iOffset: 0, jOffset: 0 }, { iOffset: 1, jOffset: 0 }]
                },
                3: {
                    "left": [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: 1 }],
                    "right": [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: -1 }]
                }
            }
        };

        // get_coordinates returns the coordinates of the tetrimino that are currently filled.
        obj.get_coordinates = function () {
            if (obj.type in rotation_map) {
                const offsets = rotation_map[obj.type][obj.rotation_index];
                let coords = [];
                offsets.forEach((off) => {
                    coords.push({ i: obj.i + off.iOffset, j: obj.j + off.jOffset });
                });
                return coords;
            } else {
                console.assert("Don't know how to get_coordinates for type: %s", obj.type);
            }
        };

        obj.get_height = function () {
            const coords = obj.get_coordinates();
            let min = coords[0].i;
            let max = coords[0].i;
            console.log(coords);
            for (let i = 1; i < coords.length; i++) {
                const pair = coords[i];
                console.log(pair);
                if (pair.i < min) {
                    min = pair.i;
                }
                if (pair.i > max) {
                    max = pair.i;
                }
            }
            console.assert(max >= min);
            return 1 + max - min;
        }

        obj.get_width = function () {
            const coords = obj.get_coordinates();
            let min = coords[0].j;
            let max = coords[0].j;
            for (let i = 1; i < coords.length; i++) {
                const pair = coords[i];
                if (pair.j < min) {
                    min = pair.j;
                }
                if (pair.j > max) {
                    max = pair.j;
                }
            }
            console.assert(max >= min);
            return 1 + max - min;
        }

        obj.get_rotations = function () {
            console.assert(obj.type in rotation_map);
            return rotation_map[obj.type];
        };

        obj.get_kicks = function (dir) {
            console.assert(obj.rotation_index in kick_map[obj.type]);
            console.assert(dir in kick_map[obj.type][obj.rotation_index]);
            return kick_map[obj.type][obj.rotation_index][dir];
        };

        return obj;
    }

    function game_make(opts) {
        opts = opts || {};
        const game_opts = opts;
        const obj = {};
        // tetrimino is the active tetrimino.
        let tetrimino = null;
        const grid = grid_make(opts.grid || {});
        let gravity_counter = 0;
        const kMSPerFrame = opts.kMSPerFrame || 1000 / 60;
        let lock_timer_ms = 0;
        let locking = false;
        const kDASDelayFrames = 10;
        let das_delay_frame_countdown = 0;
        const kDASRepeatFrames = 3;
        let das_repeat_frame_countdown = 0;
        const kDASNone = 0, kDASWantRight = 1, kDASRight = 2, kDASWantLeft = 3, kDASLeft = 4;
        let das_state = kDASNone;
        let total_lines_cleared = 0;
        let cleared_300 = false;
        let has_lost = false;
        const kEntryDelayFrames = 6;
        let entry_delay_counter = 0;

        obj.get_entry_delay_frames = function () {
            return kEntryDelayFrames;
        }

        obj.get_has_lost = function () {
            return has_lost;
        }

        obj.get_level = function () {
            if (opts.fixed_level) {
                return opts.fixed_level;
            }
            // Level increases every 10 lines cleared.
            return 1 + Math.floor(total_lines_cleared / 10);
        }

        obj.is_ended = function () {
            return total_lines_cleared >= 300;
        }

        obj.get_gravity = function () {
            if (opts.fixed_gravity) {
                return opts.fixed_gravity;
            }
            // When the level increases, so does the gravity.
            // The gravity reaches its maximum 20G at level 20.
            const level = obj.get_level();
            if (level >= 20) {
                return 20;
            }
            const g_map = {
                // Values 1-15 are copied from: https://harddrop.com/wiki/Tetris_Worlds
                1: 0.01667,
                2: 0.021017,
                3: 0.026977,
                4: 0.035256,
                5: 0.04693,
                6: 0.06361,
                7: 0.0879,
                8: 0.1236,
                9: 0.1775,
                10: 0.2598,
                11: 0.388,
                12: 0.59,
                13: 0.92,
                14: 1.46,
                15: 2.36,
                // Values 15-18 are computed from (0.8-((Level-1)*0.007))(Level-1)
                16: 3.9090991031125726,
                17: 6.613536242572853,
                18: 11.437940870718618,
                // Value 19 is a fixed "20" since result of formula is greater than 20.
                19: 20
            }
            console.assert(level in g_map);
            return g_map[level];
        }

        function get_lock_delay_ms() {
            // Values copied from https://www.reddit.com/r/Tetris/comments/e1ov09/comment/f8s4n31/?utm_source=share&utm_medium=web2x&context=3
            // Assuming levels are offset by one.
            const level = obj.get_level();
            if (level <= 20) {
                return 500;
            }
            const lock_delay_map = {
                21: 450,
                22: 400,
                23: 350,
                24: 300,
                25: 250,
                26: 200,
                27: 190,
                28: 180,
                29: 170,
                30: 160,
                31: 150
            }
            console.assert(level in lock_delay_map);
            return lock_delay_map[level];
        }

        // is_colliding_below returns true if tetrimino has a filled cell or floor below.
        function is_colliding_below() {
            console.assert(tetrimino);

            const t = tetrimino;
            const coords = t.get_coordinates();
            for (let i = 0; i < coords.length; i++) {
                const pair = coords[i];
                if (pair.i + 1 == grid.nrows()) {
                    return true;
                }
                if (grid.has(pair.i + 1, pair.j)) {
                    const cell = grid.get(pair.i + 1, pair.j);
                    if (cell.filled) {
                        return true;
                    }
                }
            }
            return false;
        }

        // try_rotate tries to rotate in direction `dir`.
        // All kicks are tried in sequence. If all kicks fail, rotation does not occur.
        // Returns true if rotation applied.
        function try_rotate(dir) {
            console.assert(tetrimino);
            const t = tetrimino;
            console.assert(dir == "left" || dir == "right", "expected 'left' or 'right', got %s", dir);
            const rotations = t.get_rotations();
            let target_index = dir == "right" ? t.rotation_index + 1 : t.rotation_index - 1;
            if (target_index < 0) {
                target_index = rotations.length - 1;
            } else if (target_index > rotations.length - 1) {
                target_index = 0;
            }

            // can_rotate checks if applying `kick` results in a successful rotation.
            function can_rotate(kick) {
                const rotation = rotations[target_index];
                let all_empty = true;
                for (let i = 0; i < rotation.length; i++) {
                    const pair = {
                        i: t.i + kick.iOffset + rotation[i].iOffset,
                        j: t.j + kick.jOffset + rotation[i].jOffset,
                    };
                    if (!grid.has(pair.i, pair.j)) {
                        all_empty = false;
                        break;
                    }
                    if (grid.get(pair.i, pair.j).filled) {
                        all_empty = false;
                        break;
                    }
                }
                return all_empty;
            }

            // Try to apply each kick in sequence until rotation succeeds.
            let kick_to_apply = null;
            const kicks = t.get_kicks(dir);
            for (let i = 0; i < kicks.length; i++) {
                const kick = kicks[i];
                if (can_rotate(kick)) {
                    kick_to_apply = kick;
                    break;
                }
            }

            if (kick_to_apply === null) {
                return false;
            }

            // Apply kick to position.
            t.i += kick_to_apply.iOffset;
            t.j += kick_to_apply.jOffset;
            // Apply rotation.
            t.rotation_index = target_index;
            return true;
        }

        // try_move tries to move tetrimino in direction `dir`. Returns true if move applied.
        function try_move(dir) {
            console.assert(tetrimino);
            const t = tetrimino;

            let jOffset;
            if (dir == "left") {
                jOffset = -1;
            }
            else if (dir == "right") {
                jOffset = +1;
            }
            else {
                throw "Do not know how to move in direction '" + dir + "'";
            }

            const coords = t.get_coordinates();
            for (let i = 0; i < coords.length; i++) {
                const pair = coords[i];
                if (!grid.has(pair.i, pair.j + jOffset)) {
                    return false;
                }
                const cell = grid.get(pair.i, pair.j + jOffset);
                if (cell.filled) {
                    return false;
                }
            }
            // All destination cells are clear. Apply move.
            t.j += jOffset;
            return true;
        }


        let events = {};

        function clear_events() {
            events = {
                rotate_left: false,
                rotate_right: false,
                move_left: false,
                move_right: false,
                hard_drop: false,
                soft_drop: false
            }
        }

        clear_events();

        obj.add_tetrimino = function (t) {
            console.assert(tetrimino == null);
            tetrimino = t;
        };

        obj.spawn_tetrimino = function (opts) {
            console.assert(opts);
            console.assert(opts.tetrimino_type);
            let start_i;
            let start_j;

            switch (opts.tetrimino_type) {
                case "test":
                    start_j = 1;
                    break;
                case "I":
                    start_i = 0;
                    start_j = 3;
                    break;
                case "J":
                case "L":
                case "S":
                case "Z":
                case "T":
                    start_i = -1;
                    start_j = 3;
                    break;
                case "O":
                    start_i = -1;
                    start_j = 4;
                    break;
                default:
                    console.assert(false, "do not know how to spawn tetrimino type: %s", opts.tetrimino_type);
                    return;
            }

            const t = tetrimino_make({
                type: opts.tetrimino_type,
                i: start_i,
                j: start_j
            });

            const coords = t.get_coordinates();
            for (let i = 0; i < coords.length; i++) {
                const pair = coords[i];
                if (grid.get(pair.i, pair.j).filled) {
                    // The player tops out when a piece is spawned overlapping at least one block
                    has_lost = true;
                    return;
                }
            }
            obj.add_tetrimino(t);

            // Attempt to move down immediately.
            if (!is_colliding_below()) {
                t.i++;
            }
            // Reset gravity counter.
            gravity_counter = 0;

            // If in DAS, reset repeat_frame_countdown. This agrees with observed behavior on tetris.com.
            if (das_state == kDASLeft || das_state == kDASRight) {
                das_repeat_frame_countdown = kDASRepeatFrames;
            }
        }

        function try_spawn() {
            if (tetrimino) return;
            if (game_opts.grid && game_opts.grid.use_test_grid && !game_opts.enable_spawn) return;
            entry_delay_counter++;
            if (entry_delay_counter >= kEntryDelayFrames) {
                if (game_opts.grid && game_opts.grid.use_test_grid) {
                    // Spawn a test piece.
                    obj.spawn_tetrimino({ tetrimino_type: "test" });
                } else {
                    console.assert(false, "Not implemented yet");
                }
                entry_delay_counter = 0;
            }
        }

        obj.rotate_left = function () {
            events.rotate_left = true;
        };

        obj.rotate_right = function () {
            events.rotate_right = true;
        };

        obj.move_left = function () {
            events.move_left = true;
        };

        obj.move_right = function () {
            events.move_right = true;
        };

        obj.hard_drop = function () {
            events.hard_drop = true;
        }

        obj.soft_drop = function () {
            events.soft_drop = true;
        }

        obj.tick_frame = function () {
            try_spawn();

            let t = tetrimino;
            let in_soft_drop = false;
            let did_move = false;
            let did_rotate = false;

            // Handle events.
            if (events.rotate_left) {
                if (t) {
                    did_rotate ||= try_rotate("left");
                }
            }
            if (events.rotate_right) {
                if (t) {
                    did_rotate ||= try_rotate("right");
                }
            }
            if (events.move_left) {
                // Handle Delayed Auto Shift (DAS)
                switch (das_state) {
                    case kDASRight:
                    case kDASWantRight:
                    case kDASNone:
                        // User was moving right or not moving. Make immediate move and start DAS sequence.
                        if (t) { did_move ||= try_move("left"); }
                        das_state = kDASWantLeft;
                        das_delay_frame_countdown = kDASDelayFrames;
                        break;
                    case kDASWantLeft:
                        das_delay_frame_countdown--;
                        if (das_delay_frame_countdown <= 0) {
                            // Delay has completed. Begin repeating.
                            if (t) { did_move ||= try_move("left"); }
                            das_state = kDASLeft;
                            das_repeat_frame_countdown = kDASRepeatFrames;
                        }
                        break;
                    case kDASLeft:
                        das_repeat_frame_countdown--;
                        if (das_repeat_frame_countdown <= 0) {
                            if (t) { did_move ||= try_move("left"); }
                            das_repeat_frame_countdown = kDASRepeatFrames;
                        }
                        break;
                }
            }
            if (events.move_right) {
                // Handle Delayed Auto Shift (DAS)
                switch (das_state) {
                    case kDASLeft:
                    case kDASWantLeft:
                    case kDASNone:
                        // User was moving left or not moving. Make immediate move and start DAS sequence.
                        if (t) { did_move ||= try_move("right"); }
                        das_state = kDASWantRight;
                        das_delay_frame_countdown = kDASDelayFrames;
                        break;
                    case kDASWantRight:
                        das_delay_frame_countdown--;
                        if (das_delay_frame_countdown <= 0) {
                            // Delay has completed. Begin repeating.
                            if (t) { did_move ||= try_move("right"); }
                            das_state = kDASRight;
                            das_repeat_frame_countdown = kDASRepeatFrames;
                        }
                        break;
                    case kDASRight:
                        das_repeat_frame_countdown--;
                        if (das_repeat_frame_countdown <= 0) {
                            if (t) { did_move ||= try_move("right"); }
                            das_repeat_frame_countdown = kDASRepeatFrames;
                        }
                        break;
                }
            }

            if (!events.move_left && !events.move_right) {
                das_state = kDASNone;
            }

            if (events.hard_drop) {
                if (t) {
                    while (!is_colliding_below()) {
                        t.i++;
                    }
                    locking = true;
                    lock_timer_ms = 0; // Lock this frame.
                }
            }
            if (events.soft_drop) {
                in_soft_drop = true;
            }
            clear_events();

            if (t) {
                // The player tops out when a block is pushed above the 20-row buffer zone.
                const coords = t.get_coordinates();
                for (let i = 0; i < coords.length; i++) {
                    const pair = coords[i];
                    if (!grid.has(pair.i, pair.j)) {
                        has_lost = true;
                        // Remove tetrimino.
                        tetrimino = null;
                        t = null;
                    }
                }

            }

            // Apply gravity.
            // Tetriminos move at a rate of `gravity` cells per frame.
            if (t) {
                let gravity = obj.get_gravity();
                // From https://tetris.wiki/Drop
                // "Soft dropping a tetromino generally makes it falls at around 20 to 60 blocks per second, as fast as or faster than DAS"
                // tetris.com appears to use the same speed as DAS. Default DAS is 50ms.
                // 50ms is .3 frames.
                if (in_soft_drop && gravity < .3) {
                    gravity_counter += .3;
                } else {
                    gravity_counter += gravity;
                }

                while (gravity_counter >= 1) {
                    if (!is_colliding_below()) {
                        t.i++;
                    }
                    gravity_counter -= 1;
                    if (gravity_counter < 0) {
                        gravity_counter = 0;
                    }
                }
            }

            // Start lock timer.
            // If Tetrimino is colliding with block below, start the lock timer.
            if (t && is_colliding_below()) {
                if (!locking) {
                    locking = true;
                    lock_timer_ms = get_lock_delay_ms() + kMSPerFrame; // Add 1 frame so locking state excludes current frame.
                } else {
                    // From https://harddrop.com/wiki/Tetris_at_tetris.com:
                    // "The game uses move-reset lock delay. That means every time a piece is moved or rotated, lock delay is reset and the piece is still active until the delay runs out (or the piece is moved or rotated 15 times before descending)."
                    if (did_move || did_rotate) {
                        lock_timer_ms = get_lock_delay_ms() + kMSPerFrame;
                    }
                }
            } else {
                locking = false;
            }

            // Apply lock.
            let fill_occurred = false;
            if (locking) {
                lock_timer_ms -= kMSPerFrame;
                if (lock_timer_ms <= 0) {
                    let is_visible = false;
                    // Fill cells with tetrimino.
                    const coords = t.get_coordinates();
                    for (let i = 0; i < coords.length; i++) {
                        const pair = coords[i];
                        const cell = grid.get(pair.i, pair.j);
                        cell.filled = true;
                        if (grid.has_visible(pair.i, pair.j)) {
                            is_visible = true;
                        }
                    }
                    if (!is_visible) {
                        // The player tops out when a piece locks completely above the visible portion of the playfield.
                        has_lost = true;
                    }
                    // Reset tetrimino.
                    tetrimino = null;
                    fill_occurred = true;
                }
            }

            // Check for line clears.
            if (fill_occurred) {
                let lines_cleared = 0;
                for (let i = 0; i < grid.nrows(); i++) {
                    let can_be_cleared = true;
                    for (let j = 0; j < grid.ncols(); j++) {
                        if (!grid.get(i, j).filled) {
                            can_be_cleared = false;
                            break;
                        }
                    }
                    if (can_be_cleared) {
                        // Clear, and shift cell fills down.
                        for (let ip = i; ip >= 0; ip--) {
                            for (let jp = 0; jp < grid.ncols(); jp++) {
                                const to = grid.get(ip, jp);
                                if (ip == 0) {
                                    to.filed = false;
                                } else {
                                    const from = grid.get(ip - 1, jp);
                                    to.filled = from.filled;
                                }
                            }
                        }
                        lines_cleared++;
                    }
                }

                if (lines_cleared > 0) {
                    total_lines_cleared += lines_cleared;
                }
            }
        };

        // render_text renders the tetris game in text.
        // Used for testing.
        // F == Fill
        // # == Tetrimino
        // . == Empty
        obj.render_text = function (opts) {
            const text_grid = [];
            if (opts && opts.render_buffer) {
                for (let i = -1 * grid.nrows(); i < 0; i++) {
                    const row = [];
                    for (let j = 0; j < grid.ncols(); j++) {
                        const cell = grid.get(i, j);
                        if (cell.filled) {
                            row.push("F");
                        } else {
                            row.push(".");
                        }
                    }
                    text_grid.push(row);
                }
                // Add a row of `-` characters to separate buffer from visible.
                const row = [];
                for (let j = 0; j < grid.ncols(); j++) {
                    row.push("-");
                }
                text_grid.push(row);
            }
            for (let i = 0; i < grid.nrows(); i++) {
                const row = [];
                for (let j = 0; j < grid.ncols(); j++) {
                    const cell = grid.get(i, j);
                    if (cell.filled) {
                        row.push("F");
                    } else {
                        row.push(".");
                    }
                }
                text_grid.push(row);
            }
            let t = tetrimino;
            if (t) {
                if (t.type == "test") {
                    const coords = t.get_coordinates();
                    coords.forEach((pair) => {
                        let ip = pair.i;
                        if (opts && opts.render_buffer) {
                            if (ip < 0) {
                                ip += grid.nrows();
                            } else {
                                ip += grid.nrows() + 1;
                            }
                        }
                        if (ip >= 0 && ip < text_grid.length && pair.j >= 0 && pair.j < text_grid[ip].length) {
                            text_grid[ip][pair.j] = "#";
                        }
                    });
                } else {
                    throw "Do not know how to apply tetrimino of type: " + t.type
                }
            }
            // Render to string.
            let ret = "";
            for (let i = 0; i < text_grid.length; i++) {
                if (i > 0) ret += "\n";
                ret += text_grid[i].join("");
            }
            return ret;
        };
        obj.get_grid = function () {
            // TODO: can I return a read-only view of an object?
            return grid;
        }

        let tick_counter_ms = 0;
        let prev_ms = null;
        obj.loop = function (opts) {
            const curr_ms = Date.now();
            if (prev_ms === null) {
                prev_ms = curr_ms;
            }
            const delta_ms = curr_ms - prev_ms;
            prev_ms = curr_ms;
            tick_counter_ms += delta_ms;

            while (tick_counter_ms >= kMSPerFrame) {
                obj.tick_frame();
                tick_counter_ms -= kMSPerFrame;
            }

            if (opts && opts.render_text_element) {
                const text = obj.render_text();
                opts.render_text_element.innerText = text;
            }
            window.requestAnimationFrame(function () {
                obj.loop(opts);
            });
        }

        obj.register_event_listeners = function () {
            document.addEventListener("keydown", function (e) {
                // console.log(e);
                switch (e.keyCode) {
                    case 40:
                        // down arrow.
                        obj.soft_drop();
                        break;
                    case 37:
                        // left arrow.
                        obj.move_left();
                        break;
                    case 39:
                        // right arrow.
                        obj.move_right();
                        break;
                    case 38:
                        // up arrow.
                        obj.rotate_right();
                        break;
                    case 32:
                        // space.
                        obj.hard_drop();
                        break;
                }
                if (e.keyCode == 40) {
                    // down arrow
                }
                else if (e.keyCode == '37') {
                    // left arrow
                }
                else if (e.keyCode == '39') {
                    // right arrow
                }
            });
        }
        return obj;
    }

    // Tests ... begin
    function assert_rendered(game, expected, opts) {
        const got = game.render_text(opts);
        expected = expected.join("\n");
        console.assert(got == expected, "expected grid:\n%s\ngot grid:\n%s\n", expected, got);
    }
    function test_add_tetrimino() {
        const game = game_make({ grid: { use_test_grid: true } });
        game.add_tetrimino(tetrimino_make());
        assert_rendered(game,
            [
                ".##..",
                ".....",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
    }
    function test_gravity() {
        const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: .5 });
        game.add_tetrimino(tetrimino_make());
        assert_rendered(game,
            [
                ".##..",
                ".....",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
        game.tick_frame();
        assert_rendered(game,
            [
                ".##..",
                ".....",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
        game.tick_frame();
        assert_rendered(game,
            [
                ".....",
                ".##..",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
        // Test gravity > 1
        {
            const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: 2 });
            game.add_tetrimino(tetrimino_make());
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
    }
    function test_lock() {
        const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: 1 });
        game.add_tetrimino(tetrimino_make({ i: 4 }));
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".##..",
                "....."
            ]);
        game.tick_frame();
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".....",
                ".##.."
            ]);
        // Tick 29 frames.
        for (let i = 0; i < 29; i++) game.tick_frame();
        // Expect still not locked.
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".....",
                ".##.."
            ]);
        // Wait another frame.
        game.tick_frame();
        // Expect locked.
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".....",
                ".FF.."
            ]);

        // Test lock with high fixed_gravity.
        {
            const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: 4 });
            game.add_tetrimino(tetrimino_make({ i: 4 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##..",
                    "....."
                ]);
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##.."
                ]);
            // Tick 29 frames.
            for (let i = 0; i < 29; i++) game.tick_frame();
            // Expect still not locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##.."
                ]);
            // Wait another frame.
            game.tick_frame();
            // Expect locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".FF.."
                ]);
        }

        // Test after 20G, lock delay decreases 
        {
            const game = game_make({ grid: { use_test_grid: true }, fixed_level: 21 });
            const grid = game.get_grid();
            game.add_tetrimino(tetrimino_make({ i: 5 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##.."
                ]);
            // Expect lock delay after 27 frames.
            // Tick 26 frames.
            for (let i = 0; i < 27; i++) {
                game.tick_frame();
                // Expect still not locked.
                assert_rendered(game,
                    [
                        ".....",
                        ".....",
                        ".....",
                        ".....",
                        ".....",
                        ".##.."
                    ]);
            }

            // Wait another frame.
            game.tick_frame();
            // Expect locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".FF.."
                ]);
        }

        // Test move resets lock delay
        {
            const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: 1 });
            game.add_tetrimino(tetrimino_make({ i: 4 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##..",
                    "....."
                ]);
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##.."
                ]);
            // Tick 29 frames.
            for (let i = 0; i < 29; i++) game.tick_frame();
            // Expect still not locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##.."
                ]);
            game.move_left();
            game.tick_frame();
            // Expect not locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "##..."
                ]);
            // Tick 29 frames.
            for (let i = 0; i < 29; i++) game.tick_frame();
            // Expect still not locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "##..."
                ]);
            game.move_left();
            game.tick_frame();
            // Expect not locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "FF..."
                ]);
        }
    }

    function test_rotate() {
        // Test basic rotate.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            game.add_tetrimino(tetrimino_make({ i: 1 }));
            assert_rendered(game,
                [
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.rotate_right();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".#...",
                    ".#...",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
        // Test wall kick.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            game.add_tetrimino(tetrimino_make({ i: 0, j: 0, rotation_index: 1 }));
            assert_rendered(game,
                [
                    "#....",
                    "#....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.rotate_right();
            game.tick_frame();
            assert_rendered(game,
                [
                    "##...",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
        // Test floor kick.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            game.add_tetrimino(tetrimino_make({ i: 5, j: 1, rotation_index: 0 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##.."
                ]);
            game.rotate_right();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".#...",
                    ".#..."
                ]);
        }
        // Test failed rotation.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            grid.get(4, 1).filled = true;
            grid.get(5, 1).filled = true;
            game.add_tetrimino(tetrimino_make({ i: 4, j: 0, rotation_index: 1 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "#F...",
                    "#F..."
                ]);
            game.rotate_left();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "#F...",
                    "#F..."
                ]);
        }
    }

    function test_line_clear() {
        function fill_region(grid, start, end) {
            console.assert(start.i <= end.i);
            console.assert(start.j <= end.j);
            for (let i = start.i; i <= end.i; i++) {
                for (let j = start.j; j <= end.j; j++) {
                    grid.get(i, j).filled = true;
                }
            }
        }
        // Test single line clear.
        {
            const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: 1 });
            const grid = game.get_grid();
            fill_region(grid, { i: 5, j: 0 }, { i: 5, j: 3 });
            game.add_tetrimino(tetrimino_make({ i: 3, j: 4, rotation_index: 1 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    "....#",
                    "....#",
                    "FFFF."
                ]);
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....#",
                    "FFFF#"
                ]);
            // Tick 30 frames to lock.
            for (let i = 0; i < 30; i++) {
                game.tick_frame();
            }
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....F"
                ]);

        }
        // Test split clear (TODO: need more pieces).
        {

        }
    }

    function test_move() {
        // Test move left / right.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            game.add_tetrimino(tetrimino_make({ i: 0, j: 1, rotation_index: 0 }));
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.move_left();
            game.tick_frame();
            assert_rendered(game,
                [
                    "##...",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            // Test that cannot move beyond wall.
            game.move_left();
            game.tick_frame();
            assert_rendered(game,
                [
                    "##...",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            // Test that cannot move beyond wall.
            game.move_right();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
        // Test delayed auto shift.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            game.add_tetrimino(tetrimino_make({ i: 0, j: 3, rotation_index: 0 }));
            assert_rendered(game,
                [
                    "...##",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.move_left();
            game.tick_frame();
            assert_rendered(game,
                [
                    "..##.",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            // After 9 frames, no move has occurred yet.
            for (let i = 0; i < 9; i++) {
                game.move_left();
                game.tick_frame();
            }
            assert_rendered(game,
                [
                    "..##.",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            // After 10th frame, enter Delayed Auto Shift.
            game.move_left();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            // In Delayed Auto Shift, move every 3 frames.
            for (let i = 0; i < 2; i++) {
                game.move_left();
                game.tick_frame();
            }
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.move_left();
            game.tick_frame();
            assert_rendered(game,
                [
                    "##...",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
        // Delayed Auto Shift can be entered before piece is spawned.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();

            // Tick 11 frames to enter DAS. Tick 1 more frame to verify DAS counter resets on spawn.
            for (let i = 0; i < 11 + 1; i++) {
                game.move_left();
                game.tick_frame();
            }

            // Use spawn_tetrimino. spawn_tetrimino resets DAS frame repeat counter.
            game.spawn_tetrimino({ tetrimino_type: "test" });
            // Expect exactly 3 frames until moving left.
            for (let i = 0; i < 3; i++) {
                assert_rendered(game,
                    [
                        ".....",
                        ".##..",
                        ".....",
                        ".....",
                        ".....",
                        "....."
                    ]);
                game.move_left();
                game.tick_frame();
            }
            assert_rendered(game,
                [
                    ".....",
                    "##...",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
    }

    function test_hard_drop() {
        // Test move left / right.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            game.add_tetrimino(tetrimino_make({ i: 0, j: 1, rotation_index: 0 }));
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.hard_drop();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".FF.."
                ]);
        }
    }

    function test_soft_drop() {
        // Test basic soft drop.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            game.add_tetrimino(tetrimino_make({ i: 0, j: 1, rotation_index: 0 }));
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            for (let i = 0; i < 3; i++) {
                game.soft_drop();
                game.tick_frame();
                assert_rendered(game,
                    [
                        ".##..",
                        ".....",
                        ".....",
                        ".....",
                        ".....",
                        "....."
                    ]);
            }
            game.soft_drop();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
        // Test soft drop does not slow down high gravity.
        {
            const game = game_make({ grid: { use_test_grid: true }, fixed_gravity: 1 });
            const grid = game.get_grid();
            game.add_tetrimino(tetrimino_make({ i: 0, j: 1, rotation_index: 0 }));
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);

            game.soft_drop();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);

        }
    }
    function test_levels() {
        // fill_bottom_row unfills all cells and fills all in bottom row except left-most.
        function fill_bottom_row(grid) {
            // Clear.
            for (let i = 0; i < grid.nrows(); i++) {
                for (let j = 0; j < grid.ncols(); j++) {
                    const cell = grid.get(i, j);
                    cell.filled = false;
                }
            }

            // Fill all in bottom row but bottom left.
            for (let j = 1; j < grid.ncols(); j++) {
                const cell = grid.get(grid.nrows() - 1, j);
                cell.filled = true;
            }
        }

        function clear_one_line(game) {
            // Assume no tetrimino is added.
            game.add_tetrimino(tetrimino_make({ i: 0, j: 0, rotation_index: 1 }));
            fill_bottom_row(game.get_grid());
            assert_rendered(game,
                [
                    "#....",
                    "#....",
                    ".....",
                    ".....",
                    ".....",
                    ".FFFF"
                ]);
            game.hard_drop();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "F...."
                ]);
        }

        // Test level increases every 10 lines cleared.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            for (let i = 0; i < 9; i++) {
                clear_one_line(game);
            }
            console.assert(game.get_level() == 1, "expected level 1, got %d", game.get_level());
            clear_one_line(game);
            console.assert(game.get_level() == 2, "expected level 2, got %d", game.get_level());
            for (let i = 0; i < 10; i++) {
                clear_one_line(game);
            }
            console.assert(game.get_level() == 3, "expected level 3, got %d", game.get_level());
        }
        // Test game ends at 300 lines cleared.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            for (let i = 0; i < 299; i++) {
                clear_one_line(game);
            }
            console.assert(!game.is_ended());
            clear_one_line(game);
            console.assert(game.is_ended());
        }
        // Test gravity caps at 20G.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            for (let i = 0; i < 19 * 10 - 1; i++) {
                clear_one_line(game);
            }
            console.assert(game.get_level() == 19, "expected level 19, got %d", game.get_level());
            console.assert(game.get_gravity() == 20, `expected gravity 20, got ${game.get_gravity()}`);
            clear_one_line(game);
            console.assert(game.get_level() == 20, "expected level 20, got %d", game.get_level());
            console.assert(game.get_gravity() == 20, `expected gravity 20, got ${game.get_gravity()}`);
            for (let i = 0; i < 10; i++) {
                clear_one_line(game);
            }
            console.assert(game.get_level() == 21, "expected level 21, got %d", game.get_level());
            console.assert(game.get_gravity() == 20, `expected gravity 20, got ${game.get_gravity()}`);
        }
    }

    function test_spawn() {
        {
            const game = game_make({ grid: { use_test_grid: true } });
            game.spawn_tetrimino({ tetrimino_type: "test" });
            assert_rendered(game,
                [
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    "....."],
            );
        }
        // Spawn starts at row 0 if row 1 is filled.
        {
            const game = game_make({ grid: { use_test_grid: true } });
            const grid = game.get_grid();
            for (let i = 1; i < grid.nrows(); i++) {
                grid.get(i, 2).filled = true;
            }
            game.spawn_tetrimino({ tetrimino_type: "test" });
            assert_rendered(game,
                [
                    ".##..",
                    "..F..",
                    "..F..",
                    "..F..",
                    "..F..",
                    "..F.."],
            );
        }
    }

    function test_loss() {
        // The player tops out when a piece is spawned overlapping at least one block.
        // Spawn starts at row 0 if row 1 is filled.
        {
            const game = game_make({ grid: { use_test_grid: true, fixed_gravity: 1 } });
            const grid = game.get_grid();
            for (let i = 1; i < grid.nrows(); i++) {
                grid.get(i, 2).filled = true;
            }
            game.spawn_tetrimino({ tetrimino_type: "test" });
            assert_rendered(game,
                [
                    ".##..",
                    "..F..",
                    "..F..",
                    "..F..",
                    "..F..",
                    "..F.."],
            );
            console.assert(!game.get_has_lost());
            // Wait for lock.
            for (let i = 0; i < 30; i++) {
                game.tick_frame();
            }
            game.tick_frame();
            assert_rendered(game,
                [
                    ".FF..",
                    "..F..",
                    "..F..",
                    "..F..",
                    "..F..",
                    "..F.."],
            );
            game.spawn_tetrimino({ tetrimino_type: "test" });
            console.assert(game.get_has_lost());
        }
        // Or a piece locks completely above the visible portion of the playfield
        {
            const game = game_make({ grid: { use_test_grid: true, fixed_gravity: 1 } });
            const grid = game.get_grid();
            for (let i = 1; i < grid.nrows(); i++) {
                for (let j = 0; j < grid.ncols(); j++) {
                    grid.get(i, j).filled = true;
                }
            }
            grid.get(0, 3).filled = true;
            game.spawn_tetrimino({ tetrimino_type: "test" });
            assert_rendered(game,
                [
                    ".##F.",
                    "FFFFF",
                    "FFFFF",
                    "FFFFF",
                    "FFFFF",
                    "FFFFF"],
            );
            console.assert(!game.get_has_lost());
            game.rotate_right();
            game.move_right();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "..#..",
                    "-----",
                    "..#F.",
                    "FFFFF",
                    "FFFFF",
                    "FFFFF",
                    "FFFFF",
                    "FFFFF"], { render_buffer: true }
            );
            game.rotate_right();
            game.tick_frame(); // Tick without moving right to reset DAS.
            game.move_right();
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "..##.",
                    "-----",
                    "...F.",
                    "FFFFF",
                    "FFFFF",
                    "FFFFF",
                    "FFFFF",
                    "FFFFF"], { render_buffer: true }
            );
            // Wait for lock.
            for (let i = 0; i < 30; i++) {
                game.tick_frame();
            }
            console.assert(game.get_has_lost());
        }
        // Or a block is pushed above the 20-row buffer zone.
        {
            // TODO: not sure if this can be tested.
        }
    }

    function test_entry_delay() {
        {
            const game = game_make({ grid: { use_test_grid: true }, enable_spawn: true });
            for (let i = 0; i < game.get_entry_delay_frames(); i++) {
                assert_rendered(game,
                    [
                        ".....",
                        ".....",
                        ".....",
                        ".....",
                        ".....",
                        "....."],
                );
                game.tick_frame();
            }
            assert_rendered(game,
                [
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    "....."],
            );
            game.hard_drop();
            game.tick_frame();
            for (let i = 0; i < game.get_entry_delay_frames(); i++) {
                assert_rendered(game,
                    [
                        ".....",
                        ".....",
                        ".....",
                        ".....",
                        ".....",
                        ".FF.."],
                );
                game.tick_frame();
            }
            assert_rendered(game,
                [
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".FF.."],
            );
        }
    }
    test_add_tetrimino();
    test_gravity();
    test_lock();
    test_rotate();
    test_line_clear();
    test_move();
    test_hard_drop();
    test_soft_drop();
    test_levels();
    test_spawn();
    test_loss();
    test_entry_delay();
    // Tests ... end

    function test_live() {
        const game = game_make({ grid: { use_test_grid: true }, enable_spawn: true });
        game.register_event_listeners();
        game.loop({
            render_text_element: document.querySelector("#display_text")
        });
    }
    // test_live();
</script>