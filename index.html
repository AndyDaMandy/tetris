<html>

<head>
    <title>Tetris</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" 
      type="image/png" 
      href="favicon.png">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-HDRY5R79EL"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-HDRY5R79EL');
    </script>
    <style type="text/css">
        * {
            padding: 0px;
            margin: 0px;
            font-family: "Courier New"
        }

        h1 {
            font-size: 20px;
        }

        #main {
            width: 424px;
            margin: 4px auto;
        }

        #settings {
            background: #EEE;
            padding: 1em;
            display: none;
        }

        table {
            width: 100%;
        }

        th {
            text-align: left;
        }
    </style>
</head>

<body>
    <div id="main">
        <canvas id="render_canvas" width="454" height="424"></canvas>
        <p><a href="https://github.com/kevinAlbs/tetris">See Source</a></p>
        <p><a href="#" id="toggle_settings">Open Settings</a></p>
        <div id="settings">
            <h1>Controls</h1>
            <table>
                <tr>
                    <th>Action</th>
                    <th>Key</th>
                </tr>
                <tr>
                    <td>Move Left</td>
                    <td>&larr;</td>
                </tr>
                <tr>
                    <td>Move Right</td>
                    <td>&rarr;</td>
                </tr>
                <tr>
                    <td>Rotate Right</td>
                    <td>&uarr;</td>
                </tr>
                <tr>
                    <td>Rotate Left</td>
                    <td>Z</td>
                </tr>
                <tr>
                    <td>Soft Drop</td>
                    <td>&darr;</td>
                </tr>
                <tr>
                    <td>Hard Drop</td>
                    <td>Space</td>
                </tr>
                <tr>
                    <td>Hold</td>
                    <td>C</td>
                </tr>
                <tr>
                    <td>Pause</td>
                    <td>P</td>
                </tr>
            </table>
        </div>
    </div>
    <script src="game.js"></script>
    <script src="tests.js"></script>
    <script>
        window.onload = main;

        const cnv = document.querySelector("#render_canvas")
        const ctx = cnv.getContext("2d");
        const kCanvasWidth = cnv.width;
        const kCanvasHeight = cnv.height;
        const kCellWidth = 20;
        const typeToFillStyle = {
            "test": "#FFF",
            "Z": "#fb0600",
            "L": "#fbb300",
            "O": "#fbe900",
            "S": "#00fb4c",
            "I": "#00e4fc",
            "J": "#0093fc",
            "T": "#d635fb"
        };

        const typeToStrokeStyle = {
            "test": "#333",
            "Z": "#740100",
            "L": "#754100",
            "O": "#756600",
            "S": "#007512",
            "I": "#006274",
            "J": "#003074",
            "T": "#571375"
        };

        function render_tetrimino(box, offsetY, type) {
            const tetrimino = tetrimino_make({ type: type, i: 0, j: 0 });
            const coords = tetrimino.get_coordinates();
            const bounds = tetrimino.get_bounds();
            const cellWidth = bounds.maxJ - bounds.minJ + 1;
            const pixelWidth = cellWidth * kCellWidth;
            const paddingWidth = (box.width - pixelWidth) / 2;
            const cellHeight = bounds.maxI - bounds.minI + 1;
            const pixelHeight = cellHeight * kCellWidth;
            const paddingHeight = (box.height - pixelHeight) / 2;
            for (let idx = 0; idx < coords.length; idx++) {
                const pair = coords[idx];
                const startX = box.x + (pair.j - bounds.minJ) * kCellWidth + paddingWidth;
                const startY = box.y + (pair.i - bounds.minI) * kCellWidth + paddingHeight + offsetY;
                ctx.fillStyle = typeToFillStyle[tetrimino.type];
                ctx.fillRect(startX, startY, kCellWidth, kCellWidth);
                ctx.lineWidth = 2;
                ctx.strokeStyle = typeToStrokeStyle[tetrimino.type];
                ctx.strokeRect(1 + startX, 1 + startY, -1 + kCellWidth, -1 + kCellWidth);
            }
        }

        let flash_score_message_counter_ms = 0;
        let flash_score_message = "";
        let flash_score_value = 0;
        function do_render(game, delta_ms) {
            const grid = game.get_grid();
            ctx.clearRect(0, 0, kCanvasWidth, kCanvasHeight);
            ctx.fillStyle = "#222"
            ctx.fillRect(0, 0, kCanvasWidth, kCanvasHeight);
            const gridBox = {
                x: 126,
                y: 12,
                width: kCellWidth * 10,
                height: kCellWidth * 20
            }

            // Render border around grid.
            {
                ctx.strokeStyle = "#EEE"
                ctx.lineWidth = 4;
                ctx.strokeRect(gridBox.x - 2, gridBox.y - 2, gridBox.width + 4, gridBox.height + 4);
            }

            // Render grid lines.
            for (let j = 0; j <= grid.ncols(); j++) {
                let startX = gridBox.x + j * kCellWidth - 1;
                ctx.fillStyle = "#333"
                ctx.fillRect(startX, gridBox.y, 2, gridBox.height);
            }

            for (let i = 0; i <= grid.nrows(); i++) {
                let startY = gridBox.y + i * kCellWidth - 1;
                ctx.fillStyle = "#333"
                ctx.fillRect(gridBox.x, startY, gridBox.width, 2);
            }

            for (let i = 0; i < grid.nrows(); i++) {
                for (let j = 0; j < grid.ncols(); j++) {
                    const cell = grid.get(i, j);
                    if (cell.filled) {
                        ctx.fillStyle = typeToFillStyle[cell.fillType];
                        ctx.fillRect(gridBox.x + j * kCellWidth, gridBox.y + i * kCellWidth, kCellWidth, kCellWidth);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = typeToStrokeStyle[cell.fillType];
                        ctx.strokeRect(1 + gridBox.x + j * kCellWidth, 1 + gridBox.y + i * kCellWidth, -1 + kCellWidth, -1 + kCellWidth);
                    }
                }
            }

            const ghost_piece = game.get_ghost_piece();
            if (ghost_piece) {
                const coords = ghost_piece.get_coordinates();
                for (let idx = 0; idx < coords.length; idx++) {
                    const pair = coords[idx];
                    if (!grid.has_visible(pair.i, pair.j)) {
                        continue;
                    }
                    ctx.fillStyle = "#555";
                    ctx.fillRect(gridBox.x + pair.j * kCellWidth, gridBox.y + pair.i * kCellWidth, kCellWidth, kCellWidth);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = "#333";
                    ctx.strokeRect(1 + gridBox.x + pair.j * kCellWidth, 1 + gridBox.y + pair.i * kCellWidth, -1 + kCellWidth, -1 + kCellWidth);
                }
            }

            const tetrimino = game.get_tetrimino();
            if (tetrimino) {
                const coords = tetrimino.get_coordinates();
                for (let idx = 0; idx < coords.length; idx++) {
                    const pair = coords[idx];
                    if (!grid.has_visible(pair.i, pair.j)) {
                        continue;
                    }
                    ctx.fillStyle = typeToFillStyle[tetrimino.type];
                    ctx.fillRect(gridBox.x + pair.j * kCellWidth, gridBox.y + pair.i * kCellWidth, kCellWidth, kCellWidth);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = typeToStrokeStyle[tetrimino.type];
                    ctx.strokeRect(1 + gridBox.x + pair.j * kCellWidth, 1 + gridBox.y + pair.i * kCellWidth, -1 + kCellWidth, -1 + kCellWidth);
                }
            }

            // Render hold piece.
            const holdBox = {
                x: 10,
                y: 30,
                width: kCellWidth * 5,
                height: kCellWidth * 3,
            };
            {
                ctx.fillStyle = "#FFF";
                ctx.font = "14px 'Courier New'";
                ctx.textAlign = "center";
                ctx.lineWidth = 3;
                ctx.fillText("Hold", holdBox.x + holdBox.width / 2, holdBox.y - 10, holdBox.width);

                // Render tetrimino centered in a bounding box.
                ctx.strokeStyle = "#EEE"
                ctx.lineWidth = 4;
                ctx.strokeRect(holdBox.x - 2, holdBox.y - 2, holdBox.width + 4, holdBox.height + 4);
                const hold_type = game.get_hold_tetrimino_type();
                if (hold_type !== null) {
                    render_tetrimino(holdBox, 0, hold_type);
                }
            }

            // Render Score + Level + Lines.
            {
                let startY = 260;
                ctx.fillStyle = "#FFF";
                ctx.font = "20px 'Courier New'";
                ctx.textAlign = "center";
                ctx.lineWidth = 3;
                ctx.fillText("Score", holdBox.x + holdBox.width / 2, startY, holdBox.width);
                ctx.font = "14px 'Courier New'";
                ctx.fillText(game.get_score_total(), holdBox.x + holdBox.width / 2, startY + 20, holdBox.width);

                startY = 320;
                ctx.fillStyle = "#FFF";
                ctx.font = "20px 'Courier New'";
                ctx.textAlign = "center";
                ctx.lineWidth = 3;
                ctx.fillText("Level", holdBox.x + holdBox.width / 2, startY, holdBox.width);
                ctx.font = "14px 'Courier New'";
                ctx.fillText(game.get_level(), holdBox.x + holdBox.width / 2, startY + 20, holdBox.width);

                startY = 380;
                ctx.fillStyle = "#FFF";
                ctx.font = "20px 'Courier New'";
                ctx.textAlign = "center";
                ctx.lineWidth = 3;
                ctx.fillText("Lines", holdBox.x + holdBox.width / 2, startY, holdBox.width);
                ctx.font = "14px 'Courier New'";
                ctx.fillText(game.get_total_lines_cleared(), holdBox.x + holdBox.width / 2, startY + 20, holdBox.width);

            }

            // Render next pieces.
            const nextBox = {
                x: gridBox.x + gridBox.width + 10 + 4 + 2,
                y: holdBox.y,
                width: holdBox.width,
                height: holdBox.height
            };
            {
                ctx.fillStyle = "#FFF";
                ctx.font = "14px 'Courier New'";
                ctx.textAlign = "center";
                ctx.lineWidth = 3;
                ctx.fillText("Next", nextBox.x + nextBox.width / 2, nextBox.y - 10, nextBox.width);

                // Render tetrimino centered in a bounding box.
                ctx.strokeStyle = "#EEE"
                ctx.lineWidth = 4;
                ctx.strokeRect(nextBox.x - 2, nextBox.y - 2, nextBox.width + 4, nextBox.height + 4);

                const spawn_shuffle = game.get_spawn_shuffle();
                const next_type = (spawn_shuffle.length == 0) ? null : spawn_shuffle[0];
                if (next_type !== null) {
                    render_tetrimino(nextBox, 0, next_type);
                }
                if (spawn_shuffle.length >= 3) {
                    render_tetrimino(nextBox, nextBox.height + 4, spawn_shuffle[1]);
                    render_tetrimino(nextBox, 2 * (nextBox.height + 4), spawn_shuffle[2]);
                }
            }

            if (game.get_has_lost()) {
                ctx.fillStyle = "#FFF";
                ctx.font = "20px 'Courier New'";
                ctx.textAlign = "center";
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 3;
                ctx.strokeText("Game Over", gridBox.x + gridBox.width / 2, gridBox.y + 100, gridBox.width);
                ctx.fillText("Game Over", gridBox.x + gridBox.width / 2, gridBox.y + 100, gridBox.width);
                ctx.font = "14px 'Courier New'";
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 3;
                ctx.strokeText("Press R to restart", gridBox.x + gridBox.width / 2, gridBox.y + 120, gridBox.width);
                ctx.fillText("Press R to restart", gridBox.x + gridBox.width / 2, gridBox.y + 120, gridBox.width);
                return;
            }

            if (game.get_paused()) {
                ctx.fillStyle = "#FFF";
                ctx.font = "20px 'Courier New'";
                ctx.textAlign = "center";
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 3;
                ctx.strokeText("Paused", gridBox.x + gridBox.width / 2, gridBox.y + 100, gridBox.width);
                ctx.fillText("Paused", gridBox.x + gridBox.width / 2, gridBox.y + 100, gridBox.width);
                ctx.font = "14px 'Courier New'";
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 3;
                ctx.strokeText("Press P to unpause", gridBox.x + gridBox.width / 2, gridBox.y + 120, gridBox.width);
                ctx.fillText("Press P to unpause", gridBox.x + gridBox.width / 2, gridBox.y + 120, gridBox.width);
                return;
            }

            if (game.get_score_occurred()) {
                flash_score_message_counter_ms = 1000;
            }
            if (flash_score_message_counter_ms > 0) {
                if (game.get_score_value() > 0) {
                    flash_score_message = game.get_score_message();
                    flash_score_value = "+" + game.get_score_value();
                }
                flash_score_message_counter_ms -= delta_ms;
            } else {
                flash_score_message = "";
            }

            if (flash_score_message != "") {
                ctx.fillStyle = "#FFF";
                ctx.font = "20px 'Courier New'";
                ctx.textAlign = "center";
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 3;
                ctx.strokeText(flash_score_message, gridBox.x + gridBox.width / 2, gridBox.y + 100, gridBox.width);
                ctx.fillText(flash_score_message, gridBox.x + gridBox.width / 2, gridBox.y + 100, gridBox.width);
                ctx.font = "14px 'Courier New'";
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 3;
                ctx.strokeText(flash_score_value, gridBox.x + gridBox.width / 2, gridBox.y + 120, gridBox.width);
                ctx.fillText(flash_score_value, gridBox.x + gridBox.width / 2, gridBox.y + 120, gridBox.width);
                return;
            }
        }

        let copy_debug_info = null;
        function main() {
            const game = game_make({ grid: { use_test_grid: false }, enable_spawn: true, show_ghost_piece: true });
            game.register_event_listeners();
            game.loop({
                render_callback: function (delta_ms) { do_render(game, delta_ms); },
            });
            copy_debug_info = function () {
                console.log();
                const debug_info = game.get_debug_info();
                for (let i = 0; i < debug_info.last_n_renders.length; i++) {
                    debug_info.last_n_renders[i] = debug_info.last_n_renders[i].split("\n");
                }
                copy(JSON.stringify(debug_info, null, "    "));
                console.log("Debug info is copied. Paste into a file. Upload the file to a GitHub issue to report a bug: https://github.com/kevinAlbs/tetris/issues");
            }

            const el_toggle_settings = document.querySelector("#toggle_settings");
            const el_settings = document.querySelector("#settings");
            el_toggle_settings.addEventListener("click", function(e) {
                e.stopPropagation();
                e.preventDefault();
                const text = el_toggle_settings.innerText;
                if (text == "Open Settings") {
                    el_settings.style.display = "block";
                    el_toggle_settings.innerText = "Close Settings";
                } else if (text == "Close Settings") {
                    el_settings.style.display = "none";
                    el_toggle_settings.innerText = "Open Settings";
                } else {
                    throw "Unexpected settings text: " + text;
                }
                game.pause();
                return false;
            });
        }
        console.log("To report a bug, copy debug info with: `copy_debug_info()`");
    </script>
</body>

</html>