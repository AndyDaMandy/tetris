<script>
    "use strict"
    function cell_make(i, j) {
        return {
            filled: false
        };
    }

    function grid_make(opts) {
        opts = opts || {};
        // Make grid with 20 visible rows and 20 hidden buffer rows above.
        let nrows = 20 + 20;
        let ncols = 10;
        if (opts.use_test_grid || false) {
            nrows = 6;
            ncols = 5;
        }

        const obj = {
            data: []
        };
        for (let i = 0; i < nrows; i++) {
            const row = [];
            for (let j = 0; j < ncols; j++) {
                row.push(cell_make(i, j));
            }
            obj.data.push(row);
        }

        obj.get = function (i, j) {
            console.assert(i >= 0 && i < obj.data.length);
            console.assert(j >= 0 && j < obj.data[i].length);
            return obj.data[i][j];
        }
        obj.has = function (i, j) {
            if (!(i >= 0 && i < obj.data.length)) {
                return false;
            }
            if (!(j >= 0 && j < obj.data[i].length)) {
                return false;
            }
            return true;
        }
        obj.nrows = function () {
            return obj.data.length;
        }
        obj.ncols = function () {
            return obj.data[0].length;
        }
        return obj;
    }

    function tetrimino_make(opts) {
        opts = opts || {};
        const obj = {
            i: opts.i !== undefined ? opts.i : 0,
            j: opts.j !== undefined ? opts.j : 1,
            type: opts.type || "test",
            gravity_counter: 0,
            lock_timer: 0,
            locking: false
        };


        const offset_map = {
            /* Test shape is two blocks.
             * O is the origin.
             *
             *                 X
             *   OX   O   XO   O
             *        X
             */
            "test": [
                [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: 1 }],
                [{ iOffset: 0, jOffset: 0 }, { iOffset: 1, jOffset: 0 }],
                [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: -1 }],
                [{ iOffset: 0, jOffset: 0 }, { iOffset: 0, jOffset: 1 }]
            ]
        }

        // kick_map determines which offsets are tested when a rotation fails.
        // kick_map maps the current rotation_index and the desired direction to a sequence of kick values.
        // Refer: https://tetris.wiki/Super_Rotation_System
        const kick_map = {
            "test": {
                "0": {
                    "left": [{ iOffset: 0, jOffset: 0 }],
                    "right": [{ iOffset: 0, jOffset: 0 }]
                },
                "1": {
                    "left": [{ iOffset: 0, jOffset: 0 }],
                    "right": [{ iOffset: 0, jOffset: 0 }]
                }
            }
        };

        let rotation_index = opts.rotation_index || 0;

        // get_coordinates returns the coordinates of the tetrimino that are currently filled.
        obj.get_coordinates = function () {
            if (obj.type in offset_map) {
                const offsets = offset_map[obj.type][rotation_index];
                let coords = [];
                offsets.forEach((off) => {
                    coords.push({ i: obj.i + off.iOffset, j: obj.j + off.jOffset });
                });
                return coords;
            } else {
                console.assert("Don't know how to get_coordinates for type: %s", obj.type);
            }
        };

        obj.rotate_left = function () {
            const numOffsets = offset_map[obj.type].length;
            rotation_index += 1;
            if (rotation_index >= numOffsets) {
                rotation_index = 0;
            }
        };

        obj.rotate_right = function () {
            const numOffsets = offset_map[obj.type].length;
            rotation_index -= 1;
            if (rotation_index < 0) {
                rotation_index = numOffsets - 1;
            }
        };
        return obj;
    }

    function game_make(opts) {
        opts = opts || {};
        const obj = {};
        // tetrimino is the active tetrimino.
        let tetrimino = null;
        const grid = grid_make(opts.grid || {});
        let gravity = opts.gravity || .1;

        // is_colliding_below returns true if tetrimino has a filled cell or floor below.
        function is_colliding_below() {
            console.assert(tetrimino);

            const t = tetrimino;
            const coords = t.get_coordinates();
            for (let i = 0; i < coords.length; i++) {
                const pair = coords[i];
                if (pair.i + 1 == grid.nrows()) {
                    return true;
                }
                if (grid.has(pair.i + 1, pair.j)) {
                    const cell = grid.get(pair.i + 1, pair.j);
                    if (cell.filled) {
                        return true;
                    }
                }
            }
            return false;
        }

        obj.add_tetrimino = function (t) {
            console.assert(tetrimino == null);
            tetrimino = t;
        };

        obj.rotate_left = function () {
            if (tetrimino) {
                tetrimino.rotate_left();
            }
        };

        obj.rotate_right = function () {
            if (tetrimino) {
                tetrimino.rotate_right();
            }
        };

        obj.tick_frame = function () {
            // Tetriminos move at a rate of `gravity` cells per frame.
            let t = tetrimino;
            if (t) {
                t.gravity_counter += opts.gravity;
                while (t.gravity_counter >= 1) {
                    if (!is_colliding_below()) {
                        t.i++;
                    }
                    t.gravity_counter -= 1;
                    if (t.gravity_counter < 0) {
                        t.gravity_counter = 0;
                    }
                }
            }

            // If Tetrimino is colliding with block below, start the lock timer.
            if (is_colliding_below()) {
                if (!t.locking) {
                    t.locking = true;
                    t.lock_timer = 30 + 1; // Add 1 so locking state is 30 frames.
                }
            } else {
                // TODO: if tetrimino was locking, and is rotated out, is locking expected to reset?
                // Assume "no". Rationale: this permits pieces to be rotated indefinitely.
            }

            if (t.locking) {
                t.lock_timer--;
                if (t.lock_timer == 0) {
                    // Fill cells with tetrimino.
                    const coords = t.get_coordinates();
                    for (let i = 0; i < coords.length; i++) {
                        const pair = coords[i];
                        const cell = grid.get(pair.i, pair.j);
                        cell.filled = true;
                    }
                    // Reset tetrimino.
                    tetrimino = null;
                }
            }
        };

        // render_text renders the tetris game in text.
        // Used for testing.
        // F == Fill
        // # == Tetrimino
        // . == Empty
        obj.render_text = function () {
            const text_grid = [];
            for (let i = 0; i < grid.nrows(); i++) {
                const row = [];
                for (let j = 0; j < grid.ncols(); j++) {
                    const cell = grid.get(i, j);
                    if (cell.filled) {
                        row.push("F");
                    } else {
                        row.push(".");
                    }
                }
                text_grid.push(row);
            }
            let t = tetrimino;
            if (t) {
                if (t.type == "test") {
                    const coords = t.get_coordinates();
                    coords.forEach((pair) => {
                        if (pair.i >= 0 && pair.i < text_grid.length && pair.j >= 0 && pair.j < text_grid[pair.i].length) {
                            text_grid[pair.i][pair.j] = "#";
                        }
                    });
                } else {
                    throw "Do not know how to apply tetrimino of type: " + t.type
                }
            }
            // Render to string.
            let ret = "";
            for (let i = 0; i < grid.nrows(); i++) {
                if (i > 0) ret += "\n";
                ret += text_grid[i].join("");
            }
            return ret;
        };
        obj.get_grid = function () {
            // TODO: can I return a read-only view of an object?
            return grid;
        }
        return obj;
    }

    // Tests ... begin
    function assert_rendered(game, expected) {
        const got = game.render_text();
        expected = expected.join("\n");
        console.assert(got == expected, "expected grid:\n%s\ngot grid:\n%s\n", expected, got);
    }
    function test_add_tetrimino() {
        const game = game_make({ grid: { use_test_grid: true } });
        game.add_tetrimino(tetrimino_make());
        assert_rendered(game,
            [
                ".##..",
                ".....",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
    }
    function test_gravity() {
        const game = game_make({ grid: { use_test_grid: true }, gravity: .5 });
        game.add_tetrimino(tetrimino_make());
        assert_rendered(game,
            [
                ".##..",
                ".....",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
        game.tick_frame();
        assert_rendered(game,
            [
                ".##..",
                ".....",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
        game.tick_frame();
        assert_rendered(game,
            [
                ".....",
                ".##..",
                ".....",
                ".....",
                ".....",
                "....."
            ]);
        // Test gravity > 1
        {
            const game = game_make({ grid: { use_test_grid: true }, gravity: 2 });
            game.add_tetrimino(tetrimino_make());
            assert_rendered(game,
                [
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
    }
    function test_lock() {
        const game = game_make({ grid: { use_test_grid: true }, gravity: 1 });
        game.add_tetrimino(tetrimino_make({ i: 4 }));
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".##..",
                "....."
            ]);
        game.tick_frame();
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".....",
                ".##.."
            ]);
        // Tick 29 frames.
        for (let i = 0; i < 29; i++) game.tick_frame();
        // Expect still not locked.
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".....",
                ".##.."
            ]);
        // Wait another frame.
        game.tick_frame();
        // Expect locked.
        assert_rendered(game,
            [
                ".....",
                ".....",
                ".....",
                ".....",
                ".....",
                ".FF.."
            ]);

        // Test lock with high gravity.
        {
            const game = game_make({ grid: { use_test_grid: true }, gravity: 4 });
            game.add_tetrimino(tetrimino_make({ i: 4 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##..",
                    "....."
                ]);
            game.tick_frame();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##.."
                ]);
            // Tick 29 frames.
            for (let i = 0; i < 29; i++) game.tick_frame();
            // Expect still not locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".##.."
                ]);
            // Wait another frame.
            game.tick_frame();
            // Expect locked.
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    ".FF.."
                ]);
        }
    }

    function test_rotate() {
        // Test basic rotate.
        {
            const game = game_make({ grid: { use_test_grid: true }, gravity: 1 });
            game.add_tetrimino(tetrimino_make({ i: 1 }));
            assert_rendered(game,
                [
                    ".....",
                    ".##..",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.rotate_left();
            assert_rendered(game,
                [
                    ".....",
                    ".#...",
                    ".#...",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
        // Test wall kick.
        {
            const game = game_make({ grid: { use_test_grid: true }, gravity: 1 });
            game.add_tetrimino(tetrimino_make({ i: 0, j: 0, rotation_index: 1 }));
            assert_rendered(game,
                [
                    "#....",
                    "#....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
            game.rotate_left();
            assert_rendered(game,
                [
                    "##...",
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "....."
                ]);
        }
        // Test failed rotation.
        {
            const game = game_make({ grid: { use_test_grid: true }, gravity: 1 });
            const grid = game.get_grid();
            grid.get(4, 1).filled = true;
            grid.get(5, 1).filled = true;
            game.add_tetrimino(tetrimino_make({ i: 4, j: 0, rotation_index: 1 }));
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "#F...",
                    "#F..."
                ]);
            game.rotate_left();
            assert_rendered(game,
                [
                    ".....",
                    ".....",
                    ".....",
                    ".....",
                    "#F...",
                    "#F..."
                ]);
        }
    }
    test_add_tetrimino();
    test_gravity();
    test_lock();
    test_rotate();
    // Tests ... end
</script>